From f0f018b58ee8a790ee0e5074e665c07b714a4f29 Mon Sep 17 00:00:00 2001
From: jon brabender <jon.brabender@renesas.com>
Date: Wed, 4 Oct 2023 18:56:15 +0300
Subject: [PATCH 16/40] drm: rcar-rvgc: Add support for multiple drm layers

Make the changes to support multiple drm layers.

NOTE: As the previous commit immediately adds code without trailing
whitespaces and with correct indentation, these changes have been
removed from this commit to avoid cluttering it.

Additionally, the original commit adds the -Og compilation flag, but it
has been decided to remove it.

Signed-off-by: Vladyslav Andrishko <vladyslav.andrishko@globallogic.com>
---
 drivers/gpu/drm/rcar-rvgc/rcar_rvgc_drv.c    |   9 +-
 drivers/gpu/drm/rcar-rvgc/rcar_rvgc_drv.h    |   6 +
 drivers/gpu/drm/rcar-rvgc/rcar_rvgc_kms.c    | 172 +++----
 drivers/gpu/drm/rcar-rvgc/rcar_rvgc_pipe.c   | 467 +++++++++++++------
 drivers/gpu/drm/rcar-rvgc/rcar_rvgc_pipe.h   |  27 +-
 drivers/gpu/drm/rcar-rvgc/rcar_rvgc_taurus.c | 126 ++++-
 drivers/gpu/drm/rcar-rvgc/rcar_rvgc_taurus.h |  68 +--
 7 files changed, 608 insertions(+), 267 deletions(-)

diff --git a/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_drv.c b/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_drv.c
index b15295e7300b..a82be701de7c 100644
--- a/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_drv.c
+++ b/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_drv.c
@@ -29,8 +29,11 @@
 #include <linux/of_reserved_mem.h>
 #include "r_taurus_rvgc_protocol.h"
 
-#define RCAR_RVGC_DRM_NAME     "rcar-rvgc"
 
+//#define RCAR_RVGC_DRM_NAME     "rcar-rvgc"
+#define RCAR_RVGC_DRM_NAME     "rcar-du"
+static bool update_primary_plane = 1;
+module_param(update_primary_plane, bool, 0);
 
 /* -----------------------------------------------------------------------------
  * RPMSG operations
@@ -146,8 +149,6 @@ static struct drm_driver rcar_rvgc_driver = {
 	.date			= "20190408",
 	.fops			= &rcar_rvgc_fops,
 	.lastclose		= rcar_rvgc_lastclose,
-	.enable_vblank		= rcar_rvgc_crtc_enable_vblank,
-	.disable_vblank		= rcar_rvgc_crtc_disable_vblank,
 };
 
 
@@ -190,10 +191,12 @@ static int rcar_rvgc_probe(struct rpmsg_device* rpdev) {
 		return -ENOMEM;
 
 	dev_set_drvdata(&rpdev->dev, rcrvgc);
+	rcrvgc->update_primary_plane = update_primary_plane;
 
 	/* Save a link to struct device and struct rpmsg_device */
 	rcrvgc->dev = &rpdev->dev;
 	rcrvgc->rpdev = rpdev;
+	/* TODO: store update_primary_plane parameter in driver struct */
 
 	/* Initialize vblank_pending state */
 	rcrvgc->vblank_pending = 0;
diff --git a/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_drv.h b/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_drv.h
index aefb6f711532..b50a7b3db281 100644
--- a/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_drv.h
+++ b/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_drv.h
@@ -43,10 +43,16 @@ struct rcar_rvgc_device {
 	uint8_t vblank_pending;
 	wait_queue_head_t vblank_pending_wait_queue;
 
+	/* needed for drm communication */
+	wait_queue_head_t vblank_enable_wait_queue;
+	atomic_t global_vblank_enable;
+
 	struct task_struct* vsync_thread;
 
 	struct list_head taurus_event_list_head;
 	rwlock_t event_list_lock;
+
+	bool update_primary_plane;
 };
 
 #endif /* __RCAR_RVGC_DRV_H__ */
diff --git a/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_kms.c b/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_kms.c
index fb7f3a9bd231..b835a2f638bf 100644
--- a/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_kms.c
+++ b/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_kms.c
@@ -13,8 +13,7 @@
 #include "rcar_rvgc_taurus.h"
 #include "r_taurus_rvgc_protocol.h"
 
-static wait_queue_head_t vblank_enable_wait_queue;
-static atomic_t global_vblank_enable = ATOMIC_INIT(0);
+
 
 struct rcar_rvgc_format_info {
 	u32 fourcc;
@@ -75,8 +74,8 @@ static int vsync_thread_fn(void* data) {
 
 	while (!kthread_should_stop()) {
 
-		wait_event_interruptible(vblank_enable_wait_queue, atomic_read(&global_vblank_enable));
-
+		wait_event_interruptible(rcrvgc->vblank_enable_wait_queue, atomic_read(&rcrvgc->global_vblank_enable));
+		/* TODO: Check if possible problem here ? Only one wait line needed maybe. */
 		wait_event_interruptible(rcrvgc->vblank_pending_wait_queue, rcrvgc->vblank_pending);
 
 		for (i = 0; i < nr_rvgc_pipes; i++) {
@@ -87,7 +86,8 @@ static int vsync_thread_fn(void* data) {
 			pipe_vblk_pending = test_and_clear_bit(display_idx, (long unsigned int*)&rcrvgc->vblank_pending);
 
 			if (pipe_vblk_pending && rvgc_pipe->vblank_enabled) {
-				crtc = &rvgc_pipe->drm_simple_pipe.crtc;
+				/* TODO: removed simple pipe here nothing else need to be done here */
+				crtc = &rvgc_pipe->crtc;
 
 				drm_crtc_handle_vblank(crtc);
 
@@ -103,7 +103,8 @@ static int vsync_thread_fn(void* data) {
 				drm_crtc_send_vblank_event(crtc, event);
 				spin_unlock_irqrestore(&crtc->dev->event_lock, flags);
 
-				drm_crtc_vblank_put(crtc);
+				/* JMB: Where is corresponding "get" ? */
+				// drm_crtc_vblank_put(crtc);
 			}
 		}
 	}
@@ -112,39 +113,8 @@ static int vsync_thread_fn(void* data) {
 	return 0;
 }
 
-int rcar_rvgc_crtc_enable_vblank(struct drm_device *dev, unsigned int pipe)
-{
-	int ret = 0;
-	struct drm_crtc *crtc = drm_crtc_from_index(dev, pipe);
-	struct drm_simple_display_pipe *drm_simple_pipe = container_of(crtc, struct drm_simple_display_pipe, crtc);
-	struct rcar_rvgc_pipe *rvgc_pipe = container_of(drm_simple_pipe, struct rcar_rvgc_pipe, drm_simple_pipe);
-
-	dev_dbg(dev->dev, "%s(%d)\n", __FUNCTION__, pipe);
-
-	rvgc_pipe->vblank_enabled = 1;
-	atomic_inc(&global_vblank_enable);
-	wake_up_interruptible(&vblank_enable_wait_queue);
-
-	return ret;
-}
-
-void rcar_rvgc_crtc_disable_vblank(struct drm_device *dev, unsigned int pipe)
-{
-	struct drm_crtc *crtc = drm_crtc_from_index(dev, pipe);
-	struct drm_simple_display_pipe *drm_simple_pipe = container_of(crtc, struct drm_simple_display_pipe, crtc);
-	struct rcar_rvgc_pipe *rvgc_pipe = container_of(drm_simple_pipe, struct rcar_rvgc_pipe, drm_simple_pipe);
-
-	dev_dbg(dev->dev, "%s(%d)\n", __FUNCTION__, pipe);
-
-	rvgc_pipe->vblank_enabled = 0;
-	atomic_dec(&global_vblank_enable);
-	WARN_ON(atomic_read(&global_vblank_enable) < 0);
-	return;
-}
-
-static void rcar_rvgc_atomic_commit_tail(struct drm_atomic_state *old_state)
-{
-	struct drm_device *dev = old_state->dev;
+static void rcar_rvgc_atomic_commit_tail(struct drm_atomic_state* old_state) {
+	struct drm_device* dev = old_state->dev;
 
 	/* Apply the atomic update. */
 	drm_atomic_helper_commit_modeset_disables(dev, old_state);
@@ -167,14 +137,14 @@ static const struct drm_mode_config_helper_funcs rcar_rvgc_mode_config_helper =
 	.atomic_commit_tail = rcar_rvgc_atomic_commit_tail,
 };
 
-int rcar_rvgc_modeset_init(struct rcar_rvgc_device *rcrvgc)
-{
-	struct drm_device *dev = rcrvgc->ddev;
-	struct drm_fbdev_cma *fbdev;
-	struct device_node *dt_node;
-	u32 nr_rvgc_pipes;
+int rcar_rvgc_modeset_init(struct rcar_rvgc_device* rcrvgc) {
+	struct drm_device* dev = rcrvgc->ddev;
+	struct drm_fbdev_cma* fbdev;
+	struct device_node* displays_node;
+	struct device_node* display_node;
 	int ret = 0;
-	int i;
+	int display;
+	int layer;
 
 	drm_mode_config_init(dev);
 
@@ -184,23 +154,23 @@ int rcar_rvgc_modeset_init(struct rcar_rvgc_device *rcrvgc)
 	dev->mode_config.max_height = 2160;
 	dev->mode_config.funcs = &rcar_rvgc_mode_config_funcs;
 	dev->mode_config.helper_private = &rcar_rvgc_mode_config_helper;
+	/* have drm_atomic_helper_check normalize zpos */
+	dev->mode_config.normalize_zpos = true;
 
-	dt_node = of_find_node_by_path("/rvgc");
-	if (!dt_node) {
-		dev_err(rcrvgc->dev, "Cannot find devicetree node \"/rvgc\"\n");
+	displays_node = of_find_node_by_path("/rvgc/displays");
+	if (!displays_node) {
+		dev_err(rcrvgc->dev, "Cannot find devicetree node \"/rvgc/displays\"\n");
 		ret = -EINVAL;
 		goto exit;
 	}
 
-	ret = of_property_read_u32(dt_node, "nr-displays", &nr_rvgc_pipes);
-	if (ret) {
-		dev_err(rcrvgc->dev, "can't read property \"nr-displays\" in node \"/rvgc\"\n");
-		ret = -EINVAL;
-		goto exit;
+	/* count display nodes */
+	rcrvgc->nr_rvgc_pipes = 0;
+	for_each_child_of_node(displays_node, display_node) {
+		rcrvgc->nr_rvgc_pipes++;
 	}
 
-	rcrvgc->nr_rvgc_pipes = nr_rvgc_pipes;
-	rcrvgc->rvgc_pipes = kzalloc(sizeof(struct rcar_rvgc_pipe) * nr_rvgc_pipes, GFP_KERNEL);
+	rcrvgc->rvgc_pipes = kzalloc(sizeof(struct rcar_rvgc_pipe) * rcrvgc->nr_rvgc_pipes, GFP_KERNEL);
 	if (!rcrvgc->rvgc_pipes)
 		return -ENOMEM;
 
@@ -209,49 +179,99 @@ int rcar_rvgc_modeset_init(struct rcar_rvgc_device *rcrvgc)
 	/*
 	 * Initialize display pipes
 	 */
-	for  (i=0; i<nr_rvgc_pipes ; i++) {
-		struct rcar_rvgc_pipe *rvgc_pipe = &rcrvgc->rvgc_pipes[i];
-		rvgc_pipe->idx = i;
+	display = 0;
+	for_each_child_of_node(displays_node, display_node) {
+		struct rcar_rvgc_pipe* rvgc_pipe = &rcrvgc->rvgc_pipes[display];
+		struct device_node* layers_node;
+		struct device_node* layer_node;
+
+		rvgc_pipe->idx = display;
 
-		ret = of_property_read_u32_index(dt_node, "display-mappings", i, &rvgc_pipe->display_mapping);
+		ret = of_property_read_u32(display_node, "display-map", &rvgc_pipe->display_mapping);
 		if (ret) {
-			dev_err(rcrvgc->dev, "can't read value in \"display-mappings\" index = %d\n", i);
+			dev_err(rcrvgc->dev, "can't read value in \"display-map\" display = %d\n", display);
 			ret = -EINVAL;
 			goto exit;
 		}
 
-		ret = of_property_read_u32_index(dt_node, "display-layer", i, &rvgc_pipe->display_layer);
-		if (ret) {
-			dev_err(rcrvgc->dev, "can't read value in \"display-layer\" index = %d. Using default (4)\n", i);
-			rvgc_pipe->display_layer = 4;
+		layers_node = of_get_child_by_name(display_node, "layers");
+		if (!layers_node) {
+			dev_err(rcrvgc->dev, "Cannot find display %d \"layers\" node\n", display);
+			ret = -EINVAL;
+			goto exit;
 		}
 
+		rvgc_pipe->plane_nr = 0;
+		for_each_child_of_node(layers_node, layer_node) {
+			rvgc_pipe->plane_nr++;
+		}
+
+		rvgc_pipe->planes = devm_kzalloc(rcrvgc->dev, sizeof(rvgc_pipe->planes[0]) * rvgc_pipe->plane_nr, GFP_KERNEL);
+
 		ret = rcar_rvgc_pipe_init(rcrvgc, rvgc_pipe);
 		if (ret) {
-			dev_err(rcrvgc->dev, "Pipe %d init failed: %d\n", i, ret);
+			dev_err(rcrvgc->dev, "Pipe %d init failed: %d\n", display, ret);
 			goto exit;
 		}
+
+		layer = 0;
+		for_each_child_of_node(layers_node, layer_node) {
+			struct rcar_rvgc_plane* cur_plane = &rvgc_pipe->planes[layer];
+
+			of_property_read_u32(layer_node, "layer-map", &cur_plane->hw_plane);
+			cur_plane->no_scan = of_property_read_bool(layer_node, "no-scan");
+			cur_plane->size_override = of_property_read_bool(layer_node, "size-override");
+			of_property_read_u32(layer_node, "size-w", &cur_plane->size_w);
+			of_property_read_u32(layer_node, "size-h", &cur_plane->size_h);
+			cur_plane->pos_override = of_property_read_bool(layer_node, "pos-override");
+			of_property_read_u32(layer_node, "pos-x", &cur_plane->pos_x);
+			of_property_read_u32(layer_node, "pos-y", &cur_plane->pos_y);
+			layer++;
+		}
+
+		display++;
 	}
 
-	init_waitqueue_head(&vblank_enable_wait_queue);
+	init_waitqueue_head(&rcrvgc->vblank_enable_wait_queue);
+	rcrvgc->global_vblank_enable = (atomic_t)ATOMIC_INIT(0);
+
+	if (rcrvgc->vsync_thread)
+		dev_warn(rcrvgc->dev, "vsync_thread is already running\n");
+	else
+		rcrvgc->vsync_thread = kthread_run(vsync_thread_fn,
+						   rcrvgc,
+						   "rvgc_vsync kthread");
+
 
 	/*
 	 * Initialize vertical blanking interrupts handling. Start with vblank
 	 * disabled for all CRTCs.
 	 */
-	ret = drm_vblank_init(dev, nr_rvgc_pipes);
+	ret = drm_vblank_init(dev, rcrvgc->nr_rvgc_pipes);
 	if (ret < 0) {
 		dev_err(rcrvgc->dev, "drm_vblank_init failed: %d\n", ret);
 		goto exit;
 	}
-	for  (i=0; i<nr_rvgc_pipes ; i++) {
-		struct rcar_rvgc_pipe *rvgc_pipe = &rcrvgc->rvgc_pipes[i];
-		drm_crtc_vblank_off(&rvgc_pipe->drm_simple_pipe.crtc);
+	for  (layer = 0; layer < rcrvgc->nr_rvgc_pipes; layer++) {
+		struct rcar_rvgc_pipe* rvgc_pipe = &rcrvgc->rvgc_pipes[layer];
+		drm_crtc_vblank_off(&rvgc_pipe->crtc);
 	}
 
 	/* Reset crtcs, encoders and connectors */
 	drm_mode_config_reset(dev);
 
+	/* Add zpos after structures initialized, but before CRT inits...
+	   having tough time finding place where normalized zpos correctly init */
+	for (display = 0; display < rcrvgc->nr_rvgc_pipes; display++) {
+		struct rcar_rvgc_pipe* rvgc_pipe = &rcrvgc->rvgc_pipes[display];
+		for (layer = 0;
+		     layer < rvgc_pipe->plane_nr;
+		     layer++) {
+			struct rcar_rvgc_plane* cur_plane = &rvgc_pipe->planes[layer];
+			drm_plane_create_zpos_immutable_property(&cur_plane->plane, cur_plane->hw_plane);
+		}
+	}
+
 	/*
 	 * Initializes drm_fbdev_cma struct
 	 */
@@ -263,14 +283,6 @@ int rcar_rvgc_modeset_init(struct rcar_rvgc_device *rcrvgc)
 	}
 
 	rcrvgc->fbdev = fbdev;
-
-	if (rcrvgc->vsync_thread)
-		dev_warn(rcrvgc->dev, "vsync_thread is already running\n");
-	else
-		rcrvgc->vsync_thread = kthread_run(vsync_thread_fn,
-						rcrvgc,
-						"rvgc_vsync kthread");
-
-exit:
+ exit:
 	return ret;
 }
diff --git a/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_pipe.c b/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_pipe.c
index 40dbc0b167eb..1256ea43305b 100644
--- a/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_pipe.c
+++ b/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_pipe.c
@@ -4,9 +4,12 @@
 #include "rcar_rvgc_drv.h"
 #include "rcar_rvgc_pipe.h"
 #include <drm/drm_simple_kms_helper.h>
+/* TODO: simple kms helper not needed anymore ?*/
+#include <drm/drm_atomic.h>
 #include <drm/drm_atomic_helper.h>
 #include <drm/drm_crtc.h>
 #include <drm/drm_crtc_helper.h>
+/* TODO: Need plane helper ? */
 #include <drm/drm_fb_cma_helper.h>
 #include <drm/drm_gem_cma_helper.h>
 
@@ -34,19 +37,6 @@ static int rvgc_connector_get_modes(struct drm_connector* connector) {
 	struct drm_display_mode* mode;
 
 	if (!rconn->mode) {
-		struct taurus_rvgc_res_msg res_msg;
-		int ret;
-
-		ret = rvgc_taurus_display_get_info(rvgc_dev,
-						rvgc_pipe->display_mapping,
-						&res_msg);
-		if (ret) {
-			dev_err(rvgc_dev->dev, "%s(): rvgc_taurus_display_get_info(%d) failed\n",
-				__FUNCTION__,
-				rvgc_pipe->display_mapping);
-			return ret;
-		}
-
 		rconn->mode = drm_mode_create(rvgc_dev->ddev);
 		if (!rconn->mode) {
 			dev_err(rvgc_dev->dev,
@@ -54,9 +44,9 @@ static int rvgc_connector_get_modes(struct drm_connector* connector) {
 				__FUNCTION__);
 			return 0;
 		}
-
-		rconn->mode->hdisplay = res_msg.params.ioc_display_get_info.width;
-		rconn->mode->vdisplay = res_msg.params.ioc_display_get_info.height;
+		/* The first device tree plane is the primary plane (use its dimensions) */
+		rconn->mode->hdisplay = rvgc_pipe->planes[0].size_w;
+		rconn->mode->vdisplay = rvgc_pipe->planes[0].size_h;
 
 		/* The following memebers in struct drm_display_mode
 		 * are set to some fake values just to make the
@@ -150,140 +140,361 @@ rvgc_connector_create(struct rcar_rvgc_pipe* rvgc_pipe) {
 	return connector;
 }
 
-static void rvgc_pipe_enable(struct drm_simple_display_pipe *pipe,
-			struct drm_crtc_state *crtc_state)
-{
-	struct device *ddev = pipe->plane.dev->dev;
-	struct rcar_rvgc_pipe *rvgc_pipe = container_of(pipe, struct rcar_rvgc_pipe, drm_simple_pipe);
-	dev_dbg(ddev, "%s() rvgc_pipe = %d\n", __FUNCTION__, rvgc_pipe->idx);
-	drm_crtc_vblank_on(&pipe->crtc);
+static const u32 rvgc_formats[] = {
+	DRM_FORMAT_XRGB8888,
+	DRM_FORMAT_ARGB8888,
+};
+
+static const struct drm_encoder_funcs drm_simple_kms_encoder_funcs = {
+	.destroy = drm_encoder_cleanup,
+};
+
+static int rvgc_crtc_check(struct drm_crtc* crtc,
+			   struct drm_crtc_state* state) {
+	bool has_primary = state->plane_mask &
+		BIT(drm_plane_index(crtc->primary));
+
+	/* We always want to have an active plane with an active CRTC */
+	if (has_primary != state->enable)
+		return -EINVAL;
+
+	return drm_atomic_add_affected_planes(state->state, crtc);
 }
 
-static void rvgc_pipe_disable(struct drm_simple_display_pipe *pipe)
-{
-	struct device *ddev = pipe->plane.dev->dev;
-	struct rcar_rvgc_pipe *rvgc_pipe = container_of(pipe, struct rcar_rvgc_pipe, drm_simple_pipe);
-	dev_dbg(ddev, "%s() rvgc_pipe = %d\n", __FUNCTION__, rvgc_pipe->idx);
-	drm_crtc_vblank_off(&pipe->crtc);
+static int rvgc_crtc_enable_vblank(struct drm_crtc* crtc) {  /* TODO: Check that new vblank will be enabled and old remove */
+	int ret = 0;
+	struct rcar_rvgc_pipe* rvgc_pipe = container_of(crtc, struct rcar_rvgc_pipe, crtc);
+	struct rcar_rvgc_device* rcrvgc = rvgc_pipe->rcar_rvgc_dev;
+
+	//printk(KERN_ERR "%s():%d", __FUNCTION__, __LINE__);
+
+	rvgc_pipe->vblank_enabled = 1;
+	atomic_inc(&rcrvgc->global_vblank_enable);
+	wake_up_interruptible(&rcrvgc->vblank_enable_wait_queue);
+
+	return ret;
+}
+
+static void rvgc_crtc_disable_vblank(struct drm_crtc* crtc) { /* TODO: Check that new vblank will be enabled and old remove */
+	struct rcar_rvgc_pipe* rvgc_pipe = container_of(crtc, struct rcar_rvgc_pipe, crtc);
+	struct rcar_rvgc_device* rcrvgc = rvgc_pipe->rcar_rvgc_dev;
+
+	//printk(KERN_ERR "%s():%d", __FUNCTION__, __LINE__);
+
+	rvgc_pipe->vblank_enabled = 0;
+	atomic_dec(&rcrvgc->global_vblank_enable);
+	WARN_ON(atomic_read(&rcrvgc->global_vblank_enable) < 0);
+	return;
+}
+
+
+static void rvgc_crtc_enable(struct drm_crtc* crtc,
+			     struct drm_crtc_state* old_state) {
+	//printk(KERN_ERR "%s():%d", __FUNCTION__, __LINE__);
+	drm_crtc_vblank_on(crtc);
+	drm_crtc_vblank_get(crtc);
+}
+
+static void rvgc_crtc_disable(struct drm_crtc* crtc,
+			      struct drm_crtc_state* old_state) {
+	//printk(KERN_ERR "%s():%d", __FUNCTION__, __LINE__);
+	drm_crtc_vblank_off(crtc);
+	drm_crtc_vblank_put(crtc);
 }
 
-static void rvgc_display_pipe_update(struct drm_simple_display_pipe *pipe,
-				struct drm_plane_state *old_state)
-{
-	struct drm_gem_cma_object *gem_obj;
+void rvgc_crtc_atomic_flush(struct drm_crtc* crtc,
+			    struct drm_crtc_state* old_crtc_state) {
 	int ret;
+	struct rcar_rvgc_pipe* rvgc_pipe = container_of(crtc, struct rcar_rvgc_pipe, crtc);
+	struct rcar_rvgc_device* rcrvgc    = rvgc_pipe->rcar_rvgc_dev;
+	unsigned int display_idx = rvgc_pipe->idx;
+	unsigned long flags;
 	struct taurus_rvgc_res_msg res_msg;
 
-	struct drm_plane_state *new_plane_state = pipe->plane.state;
-	struct drm_crtc *crtc = &pipe->crtc;
-	struct device *dev = pipe->plane.dev->dev;
-	struct rcar_rvgc_device *rcrvgc = dev_get_drvdata(dev);
-	struct rcar_rvgc_pipe *rvgc_pipe = container_of(pipe, struct rcar_rvgc_pipe, drm_simple_pipe);
-	unsigned int display_idx = rvgc_pipe->display_mapping;
-	unsigned int display_layer = rvgc_pipe->display_layer;
-	unsigned long flags;
+	/* Save the event in the rvgc_pipe struct so that we can send
+	 * it as soon as the Taurus notifies us. */
+	if (crtc->state->event) {
+		spin_lock_irqsave(&crtc->dev->event_lock, flags);
+		rvgc_pipe->event = crtc->state->event;
+		crtc->state->event = NULL;
+		spin_unlock_irqrestore(&crtc->dev->event_lock, flags);
+	}
+	/* Ask the Taurus server to flush the changes */
+	ret = rvgc_taurus_display_flush(rcrvgc,
+					display_idx,
+					0,
+					&res_msg);
+	if (ret) {
+		dev_err(rcrvgc->dev, "%s(): rvgc_taurus_display_flush(%d) failed\n",
+			__FUNCTION__,
+			rvgc_pipe->display_mapping);
+	}
+}
+
+static const struct drm_crtc_helper_funcs rvgc_crtc_helper_funcs = {
+	.atomic_check = rvgc_crtc_check,
+	.atomic_enable = rvgc_crtc_enable,
+	.atomic_disable = rvgc_crtc_disable,
+	.atomic_flush = rvgc_crtc_atomic_flush,
+};
+
+static const struct drm_crtc_funcs rvgc_crtc_funcs = {
+	.reset = drm_atomic_helper_crtc_reset,
+	.destroy = drm_crtc_cleanup,
+	.set_config = drm_atomic_helper_set_config,
+	.page_flip = drm_atomic_helper_page_flip,
+	.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,
+	.enable_vblank = rvgc_crtc_enable_vblank,
+	.disable_vblank = rvgc_crtc_disable_vblank,
+};
+
+static int rvgc_plane_atomic_check(struct drm_plane* plane,
+				   struct drm_plane_state* plane_state) {
+	struct rcar_rvgc_plane* rvgc_plane = container_of(plane, struct rcar_rvgc_plane, plane);
+	struct rcar_rvgc_pipe* rvgc_pipe = rvgc_plane->pipe;
+	struct drm_crtc_state* crtc_state;
+
+	crtc_state = drm_atomic_get_new_crtc_state(plane_state->state,
+						   &rvgc_pipe->crtc);
+	if (!crtc_state || !crtc_state->enable)
+		return 0; /* nothing to check when disabling or disabled */
 
+	if (plane_state->fb)
+		plane_state->visible = true;
+	else
+		plane_state->visible = false;
+
+	return 0;
+}
+
+static int plane_not_changed_drm_send_event(struct drm_plane* plane,
+					    struct drm_plane_state* old_state) {
+	struct drm_plane_state* new_plane_state = plane->state;
+	struct rcar_rvgc_plane* rvgc_plane      = container_of(plane, struct rcar_rvgc_plane,
+							       plane);
+	struct rcar_rvgc_pipe* rvgc_pipe       = rvgc_plane->pipe;
+	struct drm_crtc* crtc            = &rvgc_pipe->crtc;
+	unsigned long flags = 0;
 	/* No need to notify the Taurus server. Just send the vblank
 	     * event to notify the DRM that the commit is completed. */
 	if (crtc->state->active_changed || (new_plane_state->fb == old_state->fb)) {
 		spin_lock_irqsave(&crtc->dev->event_lock, flags);
-		drm_crtc_send_vblank_event(crtc, crtc->state->event);
+		if (NULL == crtc->state->event) {
+			pr_err("[rvgc_drm] %s():%d", __FUNCTION__, __LINE__);
+		} else {
+			drm_crtc_send_vblank_event(crtc, crtc->state->event);
+		}
 		crtc->state->event = NULL;
 		spin_unlock_irqrestore(&crtc->dev->event_lock, flags);
-		return;
+		return 1;
 	}
+	return 0;
+}
+
+static int check_refresh_primary(struct drm_plane* plane) {
+	enum drm_plane_type      plane_type      = plane->type;
+	struct device* ddev            = plane->dev->dev;
+	struct rcar_rvgc_device* rcrvgc          = dev_get_drvdata(ddev);
+	return ((plane_type == DRM_PLANE_TYPE_PRIMARY) && !rcrvgc->update_primary_plane);
+}
 
-	/* Update the framebuffer address */
-	if (new_plane_state->fb) {
-
-		gem_obj = drm_fb_cma_get_gem_obj(new_plane_state->fb, 0); //we support only single planar formats
-
-		ret = rvgc_taurus_layer_set_addr(rcrvgc,
-						display_idx,
-						display_layer,
-						gem_obj->paddr,
-						&res_msg);
-		if (ret) {
-			dev_err(rcrvgc->dev, "%s(): rvgc_taurus_layer_set_addr(display=%d, layer=%d) failed\n",
-				__FUNCTION__,
-				rvgc_pipe->display_mapping,
-				0);
+static void rvgc_plane_atomic_update(struct drm_plane* plane,
+				     struct drm_plane_state* old_state) {
+	struct drm_gem_cma_object* gem_obj;
+	struct taurus_rvgc_res_msg res_msg;
+
+	struct drm_framebuffer* fb              = plane->state->fb;
+	struct rcar_rvgc_plane* rvgc_plane      = container_of(plane, struct rcar_rvgc_plane,
+							       plane);
+	struct rcar_rvgc_pipe* rvgc_pipe       = rvgc_plane->pipe;
+	struct rcar_rvgc_device* rcrvgc          = rvgc_pipe->rcar_rvgc_dev;
+	unsigned int             display_idx     = rvgc_pipe->display_mapping;
+	int hw_plane;
+	bool pos_z_via_pvr = false;
+	int pos_x,pos_y,size_w,size_h;
+	int ret = 0;
+
+	/* Accomodate as many use case as possible by fdt/powervr.ini overrides */
+	if (rvgc_plane->no_scan) {
+		if ((0 == old_state->fb) && (0 != plane->state->fb)) {
+			dev_info(rcrvgc->dev, "id=%d is NOT being displayed (FDT has no-scan)\n", plane->base.id);
+		}
+	} else {
+		pos_x = (rvgc_plane->pos_override) ? rvgc_plane->pos_x : plane->state->crtc_x;
+		pos_y = (rvgc_plane->pos_override) ? rvgc_plane->pos_y : plane->state->crtc_y;
+		size_w = (rvgc_plane->size_override) ? rvgc_plane->size_w : plane->state->crtc_w;
+		size_h = (rvgc_plane->size_override) ? rvgc_plane->size_h : plane->state->crtc_h;
+
+		/* check if we've encoded z layer in the powervr.ini pos_y */
+		if (0x00100000 == (pos_y & 0xFFF00000)) {
+			hw_plane = (pos_y & 0x000F0000)>>16;
+			pos_y = (int)((int16_t)(pos_y & 0xFFFF));
+			pos_z_via_pvr = true;
+		} else {
+			/* zpos is being normalized by drm_atomic_helper_check
+			   ...or should be anyhow :( */
+			//hw_plane = plane->state->normalized_zpos;
+			hw_plane = plane->state->zpos;
+		}
+
+		/* determine why we're here...*/
+		if ((0 == old_state->fb) && (0 != plane->state->fb)) {
+			dev_info(rcrvgc->dev, "Reserve id=%d, layer=%d (via %s):%sx=%d, y=%d, %sw=%d, h=%d\n",
+				 plane->base.id, hw_plane, (pos_z_via_pvr) ? "PVR":"FDT",
+				 (rvgc_plane->pos_override) ? "Force Pos,":"", pos_x, pos_y,
+				 (rvgc_plane->size_override) ? "Force Size,":"", size_w, size_h);
+			/* enabling */
+			ret = rvgc_taurus_plane_reserve(rcrvgc,
+							display_idx,
+							hw_plane,
+							&res_msg);
+			if (ret) {
+				dev_err(rcrvgc->dev, "%s(): rvgc_taurus_plane_reserve(display=%d, id=%d, layer=%d) failed\n",
+					__FUNCTION__, display_idx, plane->base.id, hw_plane);
+				rvgc_plane->plane_reserved = false;
+				return;
+			}
+			rvgc_plane->plane_reserved = true;
+
+			ret = rvgc_taurus_layer_set_size(rcrvgc,
+							 display_idx,
+							 hw_plane,
+							 size_w,
+							 size_h,
+							 &res_msg);
+			if (ret) {
+				dev_err(rcrvgc->dev, "%s(): rvgc_taurus_layer_set_size(display=%d, id=%d, layer=%d) failed\n",
+					__FUNCTION__, display_idx, plane->base.id, hw_plane);
+			}
+			ret = rvgc_taurus_layer_set_pos(rcrvgc,
+							display_idx,
+							hw_plane,
+							pos_x,
+							pos_y,
+							&res_msg);
+			if (ret) {
+				dev_err(rcrvgc->dev, "%s(): rvgc_taurus_layer_set_position(display=%d, id=%d, layer=%d) failed\n",
+					__FUNCTION__, display_idx, plane->base.id, hw_plane);
+			}
 			return;
 		}
-	}
 
-	/* Save the event in the rvgc_pipe struct so that we can send
-	 * it as soon as the Taurus notifies us. */
-	drm_crtc_vblank_get(&pipe->crtc);
+		/* don't proceed from here if we don't actually have plane */
+		if (!rvgc_plane->plane_reserved) {
+			return;
+		}
 
-	spin_lock_irqsave(&crtc->dev->event_lock, flags);
-	rvgc_pipe->event = crtc->state->event;
-	crtc->state->event = NULL;
-	spin_unlock_irqrestore(&crtc->dev->event_lock, flags);
+		if ((0 != old_state->fb) && (0 == plane->state->fb)) {
+			/* disabling */
+			dev_info(rcrvgc->dev, "Release id=%d, layer=%d\n", plane->base.id, hw_plane);
+			ret = rvgc_taurus_layer_release(rcrvgc, display_idx, hw_plane, &res_msg);
+			rvgc_plane->plane_reserved = false;
+			if (ret) {
+				dev_err(rcrvgc->dev, "%s(): rvgc_taurus_layer_release(display=%d, id=%d, layer=%d) failed\n",
+					__FUNCTION__, display_idx, plane->base.id, hw_plane);
+			}
+			return;
+		}
 
-	/* Ask the Taurus server to flush the changes */
-	ret = rvgc_taurus_display_flush(rcrvgc,
-					display_idx,
-					0,
-					&res_msg);
-	if (ret) {
-		dev_err(rcrvgc->dev, "%s(): rvgc_taurus_display_flush(%d) failed\n",
-			__FUNCTION__,
-			rvgc_pipe->display_mapping);
+		if (0 != plane->state->fb) {
+			/* updating fb */
+			gem_obj = drm_fb_cma_get_gem_obj(fb, 0); //we support only single planar formats
+			ret = rvgc_taurus_layer_set_addr(rcrvgc, display_idx, hw_plane, gem_obj->paddr, &res_msg);
+			if (ret) {
+				dev_err(rcrvgc->dev, "%s(): rvgc_taurus_layer_set_addr(display=%d, id=%d, layer=%d) failed\n",
+					__FUNCTION__, display_idx, plane->base.id, hw_plane);
+			}
+			return;
+		}
+
+		WARN_ON(!plane->state->fb);
 	}
 }
 
-static int rvgc_display_pipe_prepare_fb(struct drm_simple_display_pipe *pipe,
-					struct drm_plane_state *plane_state)
-{
-	return drm_fb_cma_prepare_fb(&pipe->plane, plane_state);
+static int rvgc_plane_prepare_fb(struct drm_plane* plane,
+				 struct drm_plane_state* state) {
+	return drm_fb_cma_prepare_fb(plane, state);
+}
+
+static void rvgc_plane_cleanup_fb(struct drm_plane* plane,
+				  struct drm_plane_state* state) {
+
 }
 
-static const struct drm_simple_display_pipe_funcs rvgc_pipe_funcs = {
-	.enable = rvgc_pipe_enable,
-	.disable = rvgc_pipe_disable,
-	.update = rvgc_display_pipe_update,
-	.prepare_fb = rvgc_display_pipe_prepare_fb,
+static const struct drm_plane_helper_funcs rvgc_plane_helper_funcs = {
+	.prepare_fb = rvgc_plane_prepare_fb,
+	.cleanup_fb = rvgc_plane_cleanup_fb,
+	.atomic_check = rvgc_plane_atomic_check,
+	.atomic_update = rvgc_plane_atomic_update,
 };
 
-static const u32 rvgc_formats[] = {
-        DRM_FORMAT_XRGB8888,
-        DRM_FORMAT_ARGB8888,
+static const struct drm_plane_funcs rvgc_plane_funcs = {
+	.update_plane		= drm_atomic_helper_update_plane,
+	.disable_plane		= drm_atomic_helper_disable_plane,
+	.destroy		= drm_plane_cleanup,
+	.reset			= drm_atomic_helper_plane_reset,
+	.atomic_duplicate_state	= drm_atomic_helper_plane_duplicate_state,
+	.atomic_destroy_state	= drm_atomic_helper_plane_destroy_state,
 };
 
-int rcar_rvgc_pipe_init(struct rcar_rvgc_device *rvgc_dev,
-			struct rcar_rvgc_pipe *rvgc_pipe)
-{
-	int ret = 0;
-	struct drm_device *drm = rvgc_dev->ddev;
-	struct drm_connector *connector;
-	struct taurus_rvgc_res_msg res_msg;
-	int rvgc_layer_width;
-	int rvgc_layer_height;
+static int overlay_pipe_init(struct rcar_rvgc_device* rvgc_dev,
+			     struct rcar_rvgc_pipe* rvgc_pipe) {
+
+	int ret = 0, i;
+	struct drm_device* ddev = rvgc_dev->ddev;
+	struct drm_crtc* crtc = &rvgc_pipe->crtc;
+	struct drm_encoder* encoder = &rvgc_pipe->encoder;
+	struct drm_connector* connector;
 
 	rvgc_pipe->rcar_rvgc_dev = rvgc_dev;
+	rvgc_pipe->event = NULL;
+	for (i = 0; i < rvgc_pipe->plane_nr; i++) {
+		enum drm_plane_type type = i == 0
+			? DRM_PLANE_TYPE_PRIMARY
+			: DRM_PLANE_TYPE_OVERLAY;
+
+		struct rcar_rvgc_plane* plane = &rvgc_pipe->planes[i];
+		plane->pipe = rvgc_pipe;
+
+		drm_plane_helper_add(&plane->plane, &rvgc_plane_helper_funcs);
+		ret = drm_universal_plane_init(ddev, &plane->plane,
+					       (1 << rvgc_pipe->idx),
+					       &rvgc_plane_funcs,
+					       rvgc_formats, ARRAY_SIZE(rvgc_formats), NULL,
+					       type, NULL);
+		if (ret)
+			return ret;
 
-	connector = rvgc_connector_create(rvgc_pipe);
+	}
 
-	ret = drm_simple_display_pipe_init(drm,
-					&rvgc_pipe->drm_simple_pipe,
-					&rvgc_pipe_funcs,
-					rvgc_formats, ARRAY_SIZE(rvgc_formats),
-					NULL,
-					connector);
-	if (ret) {
-		dev_err(rvgc_dev->dev,
-			"%s() drm_simple_display_pipe_init(pipe=%d) returned an error (%d)\n",
-			__FUNCTION__,
-			rvgc_pipe->idx,
-			ret);
+	drm_crtc_helper_add(crtc, &rvgc_crtc_helper_funcs);
+	ret = drm_crtc_init_with_planes(ddev, crtc, &rvgc_pipe->planes[0].plane, NULL,
+					&rvgc_crtc_funcs, NULL);
+	if (ret)
 		return ret;
-	}
+
+	encoder->possible_crtcs = 1 << drm_crtc_index(crtc);
+	ret = drm_encoder_init(ddev, encoder, &drm_simple_kms_encoder_funcs,
+			       DRM_MODE_ENCODER_NONE, NULL);
+	if (ret)
+		return ret;
+	connector = rvgc_connector_create(rvgc_pipe);
+
+	return drm_mode_connector_attach_encoder(connector, encoder);
+
+}
+
+static int taurus_init(struct rcar_rvgc_device* rvgc_dev,
+		       struct rcar_rvgc_pipe* rvgc_pipe) {
+
+	struct rcar_rvgc_device* rcrvgc = rvgc_pipe->rcar_rvgc_dev;
+	int ret = 0;
+	struct taurus_rvgc_res_msg res_msg;
 
 	ret = rvgc_taurus_display_init(rvgc_dev,
-				rvgc_pipe->display_mapping,
-				rvgc_pipe->display_layer,
-				&res_msg);
+				       rvgc_pipe->display_mapping,
+				       &res_msg);
 	if (ret) {
 		dev_err(rvgc_dev->dev, "%s(): rvgc_taurus_display_init(%d) failed\n",
 			__FUNCTION__,
@@ -301,28 +512,24 @@ int rcar_rvgc_pipe_init(struct rcar_rvgc_device *rvgc_dev,
 		return ret;
 	}
 
-	rvgc_layer_width = res_msg.params.ioc_display_get_info.width;
-	rvgc_layer_height = res_msg.params.ioc_display_get_info.height;
+	/* not sure we'll use this, but keep the data */
+	rvgc_pipe->display_width = res_msg.params.ioc_display_get_info.width;
+	rvgc_pipe->display_height = res_msg.params.ioc_display_get_info.height;
 
-	ret = rvgc_taurus_layer_set_size(rvgc_dev,
-					rvgc_pipe->display_mapping,
-					rvgc_pipe->display_layer,
-					rvgc_layer_width,
-					rvgc_layer_height,
-					&res_msg);
-	if (ret) {
-		dev_err(rvgc_dev->dev, "%s(): rvgc_taurus_layer_set_size(display=%d, layer=%d) failed\n",
-			__FUNCTION__,
-			rvgc_pipe->display_mapping,
-			0);
-	}
+	return ret;
+}
 
+int rcar_rvgc_pipe_init(struct rcar_rvgc_device* rvgc_dev,
+			struct rcar_rvgc_pipe* rvgc_pipe) {
+	int ret = 0;
+	ret = overlay_pipe_init(rvgc_dev, rvgc_pipe);
+	if (ret) return ret;
+	ret = taurus_init(rvgc_dev, rvgc_pipe);
 	return ret;
 }
 
-struct rcar_rvgc_pipe* rvgc_pipe_find(struct rcar_rvgc_device *rcrvgc, unsigned int pipe_idx)
-{
-	struct rcar_rvgc_pipe *rvgc_pipe = NULL;
+struct rcar_rvgc_pipe* rvgc_pipe_find(struct rcar_rvgc_device* rcrvgc, unsigned int pipe_idx) {
+	struct rcar_rvgc_pipe* rvgc_pipe = NULL;
 	unsigned int nr_rvgc_pipes = rcrvgc->nr_rvgc_pipes;
 	int i;
 	for (i = 0; i < nr_rvgc_pipes; i++) {
diff --git a/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_pipe.h b/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_pipe.h
index 9be2e1a02cc7..e3fcbe985da7 100644
--- a/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_pipe.h
+++ b/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_pipe.h
@@ -20,14 +20,35 @@
 struct rcar_rvgc_device;
 struct drm_crtc;
 
+struct rcar_rvgc_plane {
+	unsigned int hw_plane;
+	unsigned int size_w;
+	unsigned int size_h;
+	unsigned int pos_x;
+	unsigned int pos_y;
+	bool pos_override;	/* always use rcar_rvgc_plane position (read from FDT) */
+	bool size_override;	/* always use rcar_rvgc_plane size (read from FDT) */
+	bool no_scan;		/* don't output this plane to vspd */
+	bool plane_reserved;	/* we've actually managed to allocate a hardware plane */
+	struct drm_plane plane;
+	struct rcar_rvgc_pipe* pipe;
+};
+
 struct rcar_rvgc_pipe {
 	struct rcar_rvgc_device* rcar_rvgc_dev;
 	unsigned int idx;
 	unsigned int display_mapping;
-	unsigned int display_layer;
 	unsigned int vblank_enabled;
-	struct drm_simple_display_pipe drm_simple_pipe;
-	struct drm_pending_vblank_event *event;
+	unsigned int plane_nr;
+	unsigned int display_height;
+	unsigned int display_width;
+
+	struct drm_crtc crtc;
+	struct rcar_rvgc_plane* planes;
+	struct drm_encoder encoder;
+	struct drm_connector* connector;
+
+	struct drm_pending_vblank_event* event;
 };
 
 int rcar_rvgc_pipe_init(struct rcar_rvgc_device* rvgc_dev, struct rcar_rvgc_pipe* rvgc_pipe);
diff --git a/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_taurus.c b/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_taurus.c
index ef28c3b5deeb..a5155818e393 100644
--- a/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_taurus.c
+++ b/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_taurus.c
@@ -84,11 +84,10 @@ static int rvgc_taurus_send_command(struct rcar_rvgc_device* rcrvgc,
 	return ret;
 }
 
-int rvgc_taurus_display_init(struct rcar_rvgc_device *rcrvgc,
-			uint32_t display,
-			uint32_t layer,
-			struct taurus_rvgc_res_msg *res_msg)
-{
+int rvgc_taurus_plane_reserve(struct rcar_rvgc_device* rcrvgc,
+			      uint32_t display,
+			      uint32_t layer,
+			      struct taurus_rvgc_res_msg* res_msg) {
 	struct taurus_rvgc_cmd_msg cmd_msg;
 	int ret;
 
@@ -98,39 +97,51 @@ int rvgc_taurus_display_init(struct rcar_rvgc_device *rcrvgc,
 	cmd_msg.hdr.Id = rvgc_taurus_get_uniq_id();
 	cmd_msg.hdr.Channel = RVGC_TAURUS_CHANNEL;
 	cmd_msg.hdr.Cmd = R_TAURUS_CMD_IOCTL;
-	cmd_msg.hdr.Par1 = RVGC_PROTOCOL_IOC_DISPLAY_INIT;
-	cmd_msg.type = RVGC_PROTOCOL_IOC_DISPLAY_INIT;
-	cmd_msg.params.ioc_display_flush.cookie = cmd_msg.hdr.Id;
-	cmd_msg.params.ioc_display_flush.display = display;
+	cmd_msg.hdr.Par1 = RVGC_PROTOCOL_IOC_LAYER_RESERVE;
+	cmd_msg.type = RVGC_PROTOCOL_IOC_LAYER_RESERVE;
+	cmd_msg.params.ioc_layer_reserve.cookie = cmd_msg.hdr.Id;
+	cmd_msg.params.ioc_layer_reserve.display = display;
+	cmd_msg.params.ioc_layer_reserve.layer = layer;
 
 	ret = rvgc_taurus_send_command(rcrvgc, &cmd_msg, res_msg);
 	if (ret)
 		return -EPIPE;
 
 	if ((res_msg->hdr.Result != R_TAURUS_RES_COMPLETE) ||
-		(res_msg->params.ioc_display_init.res != 0)) {
+	    (res_msg->params.ioc_layer_reserve.res != 0)) {
 		return -EIO;
 	}
 
+	return 0;
+}
+
+
+int rvgc_taurus_display_init(struct rcar_rvgc_device* rcrvgc,
+			     uint32_t display,
+			     struct taurus_rvgc_res_msg* res_msg) {
+	struct taurus_rvgc_cmd_msg cmd_msg;
+	int ret = 0;
+
+	if (!res_msg)
+		return -EINVAL;
+
 	cmd_msg.hdr.Id = rvgc_taurus_get_uniq_id();
 	cmd_msg.hdr.Channel = RVGC_TAURUS_CHANNEL;
 	cmd_msg.hdr.Cmd = R_TAURUS_CMD_IOCTL;
-	cmd_msg.hdr.Par1 = RVGC_PROTOCOL_IOC_LAYER_RESERVE;
-	cmd_msg.type = RVGC_PROTOCOL_IOC_LAYER_RESERVE;
-	cmd_msg.params.ioc_layer_reserve.cookie = cmd_msg.hdr.Id;
-	cmd_msg.params.ioc_layer_reserve.display = display;
-	cmd_msg.params.ioc_layer_reserve.layer = layer;
+	cmd_msg.hdr.Par1 = RVGC_PROTOCOL_IOC_DISPLAY_INIT;
+	cmd_msg.type = RVGC_PROTOCOL_IOC_DISPLAY_INIT;
+	cmd_msg.params.ioc_display_flush.cookie = cmd_msg.hdr.Id;
+	cmd_msg.params.ioc_display_flush.display = display;
 
 	ret = rvgc_taurus_send_command(rcrvgc, &cmd_msg, res_msg);
 	if (ret)
 		return -EPIPE;
 
 	if ((res_msg->hdr.Result != R_TAURUS_RES_COMPLETE) ||
-		(res_msg->params.ioc_layer_reserve.res != 0)) {
+	    (res_msg->params.ioc_display_init.res != 0)) {
 		return -EIO;
 	}
-
-	return 0;
+	return ret;
 }
 
 int rvgc_taurus_display_get_info(struct rcar_rvgc_device* rcrvgc,
@@ -228,12 +239,46 @@ int rvgc_taurus_layer_set_size(struct rcar_rvgc_device* rcrvgc,
 	return 0;
 }
 
-int rvgc_taurus_layer_set_addr(struct rcar_rvgc_device *rcrvgc,
-			uint32_t display,
-			uint32_t layer,
-			uint32_t paddr,
-			struct taurus_rvgc_res_msg *res_msg)
-{
+int rvgc_taurus_layer_set_pos(struct rcar_rvgc_device* rcrvgc,
+			      uint32_t display,
+			      uint32_t layer,
+			      uint32_t pos_x,
+			      uint32_t pos_y,
+			      struct taurus_rvgc_res_msg* res_msg) {
+	struct taurus_rvgc_cmd_msg cmd_msg;
+	int ret;
+
+	if (!res_msg)
+		return -EINVAL;
+
+	cmd_msg.hdr.Id = rvgc_taurus_get_uniq_id();
+	cmd_msg.hdr.Channel = RVGC_TAURUS_CHANNEL;
+	cmd_msg.hdr.Cmd = R_TAURUS_CMD_IOCTL;
+	cmd_msg.hdr.Par1 = RVGC_PROTOCOL_IOC_LAYER_SET_POS;
+	cmd_msg.type = RVGC_PROTOCOL_IOC_LAYER_SET_POS;
+	cmd_msg.params.ioc_layer_set_pos.cookie =  cmd_msg.hdr.Id;
+	cmd_msg.params.ioc_layer_set_pos.display = display;
+	cmd_msg.params.ioc_layer_set_pos.layer = layer;
+	cmd_msg.params.ioc_layer_set_pos.pos_x = pos_x;
+	cmd_msg.params.ioc_layer_set_pos.pos_y = pos_y;
+
+	ret = rvgc_taurus_send_command(rcrvgc, &cmd_msg, res_msg);
+	if (ret)
+		return -EPIPE;
+
+	if ((res_msg->hdr.Result != R_TAURUS_RES_COMPLETE) ||
+	    (res_msg->params.ioc_layer_set_pos.res != 0)) {
+		return -EIO;
+	}
+
+	return 0;
+}
+
+int rvgc_taurus_layer_set_addr(struct rcar_rvgc_device* rcrvgc,
+			       uint32_t display,
+			       uint32_t layer,
+			       uint32_t paddr,
+			       struct taurus_rvgc_res_msg* res_msg) {
 	struct taurus_rvgc_cmd_msg cmd_msg;
 	int ret;
 
@@ -255,7 +300,38 @@ int rvgc_taurus_layer_set_addr(struct rcar_rvgc_device *rcrvgc,
 		return -EPIPE;
 
 	if ((res_msg->hdr.Result != R_TAURUS_RES_COMPLETE) ||
-		(res_msg->params.ioc_layer_set_addr.res != 0)) {
+	    (res_msg->params.ioc_layer_set_addr.res != 0)) {
+		return -EIO;
+	}
+
+	return 0;
+}
+
+int rvgc_taurus_layer_release(struct rcar_rvgc_device* rcrvgc,
+			      uint32_t display,
+			      uint32_t layer,
+			      struct taurus_rvgc_res_msg* res_msg) {
+	struct taurus_rvgc_cmd_msg cmd_msg;
+	int ret;
+
+	if (!res_msg)
+		return -EINVAL;
+
+	cmd_msg.hdr.Id = rvgc_taurus_get_uniq_id();
+	cmd_msg.hdr.Channel = RVGC_TAURUS_CHANNEL;
+	cmd_msg.hdr.Cmd = R_TAURUS_CMD_IOCTL;
+	cmd_msg.hdr.Par1 = RVGC_PROTOCOL_IOC_LAYER_RELEASE;
+	cmd_msg.type = RVGC_PROTOCOL_IOC_LAYER_RELEASE;
+	cmd_msg.params.ioc_layer_release.cookie =  cmd_msg.hdr.Id;
+	cmd_msg.params.ioc_layer_release.display = display;
+	cmd_msg.params.ioc_layer_release.layer = layer;
+
+	ret = rvgc_taurus_send_command(rcrvgc, &cmd_msg, res_msg);
+	if (ret)
+		return -EPIPE;
+
+	if ((res_msg->hdr.Result != R_TAURUS_RES_COMPLETE) ||
+	    (res_msg->params.ioc_layer_release.res != 0)) {
 		return -EIO;
 	}
 
diff --git a/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_taurus.h b/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_taurus.h
index 19d3b6ba840b..c8ccf1ff1fd1 100644
--- a/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_taurus.h
+++ b/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_taurus.h
@@ -6,31 +6,47 @@
 struct rcar_rvgc_device;
 struct taurus_rvgc_res_msg;
 
-int rvgc_taurus_display_init(struct rcar_rvgc_device *rcrvgc,
-			uint32_t display,
-			uint32_t layer,
-			struct taurus_rvgc_res_msg *res_msg);
-
-int rvgc_taurus_display_get_info(struct rcar_rvgc_device *rcrvgc,
-				uint32_t display,
-				struct taurus_rvgc_res_msg *res_msg);
-
-int rvgc_taurus_display_flush(struct rcar_rvgc_device *rcrvgc,
-			uint32_t display,
-			uint32_t blocking,
-			struct taurus_rvgc_res_msg *res_msg);
-
-int rvgc_taurus_layer_set_addr(struct rcar_rvgc_device *rcrvgc,
-			uint32_t display,
-			uint32_t layer,
-			uint32_t paddr,
-			struct taurus_rvgc_res_msg *res_msg);
-
-int rvgc_taurus_layer_set_size(struct rcar_rvgc_device *rcrvgc,
-			uint32_t display,
-			uint32_t layer,
-			uint32_t width,
-			uint32_t height,
-			struct taurus_rvgc_res_msg *res_msg);
+int rvgc_taurus_display_init(struct rcar_rvgc_device* rcrvgc,
+			     uint32_t display,
+			     struct taurus_rvgc_res_msg* res_msg);
+
+int rvgc_taurus_plane_reserve(struct rcar_rvgc_device* rcrvgc,
+			      uint32_t display,
+			      uint32_t layer,
+			      struct taurus_rvgc_res_msg* res_msg);
+
+int rvgc_taurus_display_get_info(struct rcar_rvgc_device* rcrvgc,
+				 uint32_t display,
+				 struct taurus_rvgc_res_msg* res_msg);
+
+int rvgc_taurus_display_flush(struct rcar_rvgc_device* rcrvgc,
+			      uint32_t display,
+			      uint32_t blocking,
+			      struct taurus_rvgc_res_msg* res_msg);
+
+int rvgc_taurus_layer_set_addr(struct rcar_rvgc_device* rcrvgc,
+			       uint32_t display,
+			       uint32_t layer,
+			       uint32_t paddr,
+			       struct taurus_rvgc_res_msg* res_msg);
+
+int rvgc_taurus_layer_release(struct rcar_rvgc_device* rcrvgc,
+			      uint32_t display,
+			      uint32_t layer,
+			      struct taurus_rvgc_res_msg* res_msg);
+
+int rvgc_taurus_layer_set_size(struct rcar_rvgc_device* rcrvgc,
+			       uint32_t display,
+			       uint32_t layer,
+			       uint32_t width,
+			       uint32_t height,
+			       struct taurus_rvgc_res_msg* res_msg);
+
+int rvgc_taurus_layer_set_pos(struct rcar_rvgc_device* rcrvgc,
+			      uint32_t display,
+			      uint32_t layer,
+			      uint32_t pos_x,
+			      uint32_t pos_y,
+			      struct taurus_rvgc_res_msg* res_msg);
 
 #endif /* __RCAR_RVGC_TAURUS_H__ */
-- 
2.25.1

