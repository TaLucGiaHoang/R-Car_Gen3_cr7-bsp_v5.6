From 3162fc3308a2c2bb82a75a97504c869c49dbc56f Mon Sep 17 00:00:00 2001
From: Sergii Piatakov <sergii.piatakov@globallogic.com>
Date: Tue, 13 Dec 2022 14:51:17 +0000
Subject: [PATCH 26/27] rcar-rvgc: align the module to the CR7 SDK v4.0

Update the module source code to align it's functionality with the CR7
SDK v4.0. The source code was taken from the Renesas Yocto BSP v5.9 with
CR7 support (safe-rendering).

This patch also updates the rvgc DTS node declaration according to the
new syntax.

Test: build, flash and boot, check Android desktop on HDMI display.
Signed-off-by: Sergii Piatakov <sergii.piatakov@globallogic.com>
---
 .../dts/renesas/salvator-xs_cr7_rproc.dtsi    |  21 +-
 drivers/gpu/drm/rcar-rvgc/r_taurus_bridge.h   |  27 +-
 .../drm/rcar-rvgc/r_taurus_rvgc_protocol.h    | 144 ++---
 drivers/gpu/drm/rcar-rvgc/rcar_rvgc_drv.c     | 107 ++--
 drivers/gpu/drm/rcar-rvgc/rcar_rvgc_drv.h     |  20 +-
 drivers/gpu/drm/rcar-rvgc/rcar_rvgc_kms.c     | 233 ++++----
 drivers/gpu/drm/rcar-rvgc/rcar_rvgc_kms.h     |  11 +-
 drivers/gpu/drm/rcar-rvgc/rcar_rvgc_pipe.c    | 535 ++++++++++++------
 drivers/gpu/drm/rcar-rvgc/rcar_rvgc_pipe.h    |  36 +-
 drivers/gpu/drm/rcar-rvgc/rcar_rvgc_taurus.c  | 183 ++++--
 drivers/gpu/drm/rcar-rvgc/rcar_rvgc_taurus.h  |  68 ++-
 11 files changed, 844 insertions(+), 541 deletions(-)

diff --git a/arch/arm64/boot/dts/renesas/salvator-xs_cr7_rproc.dtsi b/arch/arm64/boot/dts/renesas/salvator-xs_cr7_rproc.dtsi
index 87a5cc5f6ab0..81825e97f45d 100644
--- a/arch/arm64/boot/dts/renesas/salvator-xs_cr7_rproc.dtsi
+++ b/arch/arm64/boot/dts/renesas/salvator-xs_cr7_rproc.dtsi
@@ -55,17 +55,28 @@
 		#address-cells = <2>;
 		#size-cells = <2>;
 
-		/* actual display mapping will be overridden by cr7 settings */
-		nr-displays = <0x2>;
-		display-mappings = <0x0 0x1>;
-		display-layer = <0x4 0x4>;
-
 		/* 1:1 mapping for the ion address space */
 		dma-ranges = <0x0 0x80000000 0x0 0x80000000 0x0 0x18000000>;
 
 		rvgc-memory {
 			memory-region = <&cma_reserved>;
 		};
+
+		displays {
+			display-0 {
+				display-map = <1>;
+				layers {
+					primary{
+						layer-map=<0x4>;
+						size-w=<1024>;
+						size-h=<768>;
+						pos-x=<448>;
+						pos-y=<156>;
+						pos-override;
+					};
+				};
+			};
+		};
 	};
 
 	rcar-vivid {
diff --git a/drivers/gpu/drm/rcar-rvgc/r_taurus_bridge.h b/drivers/gpu/drm/rcar-rvgc/r_taurus_bridge.h
index 7de1f1847e95..a0c26de252c8 100644
--- a/drivers/gpu/drm/rcar-rvgc/r_taurus_bridge.h
+++ b/drivers/gpu/drm/rcar-rvgc/r_taurus_bridge.h
@@ -3,7 +3,8 @@
 #define R_TAURUS_BRIDGE_H
 
 #ifdef __cplusplus
-extern "C" {
+extern "C"
+{
 #endif
 
 /* This is file defines the basic command protocol between TAURUS and its guest.
@@ -85,13 +86,13 @@ extern "C" {
 */
 
 typedef struct {
-    uint32_t          Id;
-    uint32_t          Per;
-    uint32_t          Channel;
-    uint32_t          Cmd;
-    uint64_t          Par1;
-    uint64_t          Par2;
-    uint64_t          Par3;
+	uint32_t          Id;
+	uint32_t          Per;
+	uint32_t          Channel;
+	uint32_t          Cmd;
+	uint64_t          Par1;
+	uint64_t          Par2;
+	uint64_t          Par3;
 } R_TAURUS_CmdMsg_t;
 
 
@@ -108,11 +109,11 @@ typedef struct {
 */
 
 typedef struct {
-    uint32_t        Id;
-    uint32_t        Per;
-    uint32_t        Channel;
-    uint32_t        Result;
-    uint64_t        Aux;
+	uint32_t        Id;
+	uint32_t        Per;
+	uint32_t        Channel;
+	uint32_t        Result;
+	uint64_t        Aux;
 } R_TAURUS_ResultMsg_t;
 
 
diff --git a/drivers/gpu/drm/rcar-rvgc/r_taurus_rvgc_protocol.h b/drivers/gpu/drm/rcar-rvgc/r_taurus_rvgc_protocol.h
index eee317c4fe5b..fa185d961038 100644
--- a/drivers/gpu/drm/rcar-rvgc/r_taurus_rvgc_protocol.h
+++ b/drivers/gpu/drm/rcar-rvgc/r_taurus_rvgc_protocol.h
@@ -6,7 +6,7 @@
 #include "r_taurus_protocol_ids.h"
 
 #ifndef __packed
-# define __packed       __attribute__((__packed__))
+#define __packed       __attribute__((__packed__))
 #endif
 
 /*********** RVGC signal identifiers ************/
@@ -22,152 +22,152 @@
 #define RVGC_PROTOCOL_IOC_LAYER_SET_ADDR                ((TAURUS_PROTOCOL_RVGC_ID << 24) | 0xF00000)
 
 struct taurus_rvgc_ioc_layer_set_addr_in {
-    uint64_t    cookie;
-    uint32_t    display;
-    uint32_t    layer;
-    uint32_t    paddr;
+	uint64_t    cookie;
+	uint32_t    display;
+	uint32_t    layer;
+	uint32_t    paddr;
 } __packed;
 
 struct taurus_rvgc_ioc_layer_set_addr_out {
-    uint64_t    cookie;
-    uint64_t    res;
+	uint64_t    cookie;
+	uint64_t    res;
 } __packed;
 
 
 #define RVGC_PROTOCOL_IOC_LAYER_SET_POS                 ((TAURUS_PROTOCOL_RVGC_ID << 24) | 0xF00001)
 
 struct taurus_rvgc_ioc_layer_set_pos_in {
-    uint64_t    cookie;
-    uint32_t    display;
-    uint32_t    layer;
-    uint32_t    pos_x;
-    uint32_t    pos_y;
+	uint64_t    cookie;
+	uint32_t    display;
+	uint32_t    layer;
+	uint32_t    pos_x;
+	uint32_t    pos_y;
 } __packed;
 
 struct taurus_rvgc_ioc_layer_set_pos_out {
-    uint64_t    cookie;
-    uint64_t    res;
+	uint64_t    cookie;
+	uint64_t    res;
 } __packed;
 
 
 #define RVGC_PROTOCOL_IOC_LAYER_SET_SIZE                ((TAURUS_PROTOCOL_RVGC_ID << 24) | 0xF00002)
 
 struct taurus_rvgc_ioc_layer_set_size_in {
-    uint64_t    cookie;
-    uint32_t    display;
-    uint32_t    layer;
-    uint32_t    size_w;
-    uint32_t    size_h;
+	uint64_t    cookie;
+	uint32_t    display;
+	uint32_t    layer;
+	uint32_t    size_w;
+	uint32_t    size_h;
 } __packed;
 
 struct taurus_rvgc_ioc_layer_set_size_out {
-    uint64_t    cookie;
-    uint64_t    res;
+	uint64_t    cookie;
+	uint64_t    res;
 } __packed;
 
 
 #define RVGC_PROTOCOL_IOC_DISPLAY_FLUSH                 ((TAURUS_PROTOCOL_RVGC_ID << 24) | 0xF00003)
 
 struct taurus_rvgc_ioc_display_flush_in {
-    uint64_t    cookie;
-    uint32_t    display;
-    uint32_t    blocking;
+	uint64_t    cookie;
+	uint32_t    display;
+	uint32_t    blocking;
 } __packed;
 
 struct taurus_rvgc_ioc_display_flush_out {
-    uint64_t    cookie;
-    uint64_t    res;
+	uint64_t    cookie;
+	uint64_t    res;
 } __packed;
 
 
 #define RVGC_PROTOCOL_IOC_DISPLAY_INIT                  ((TAURUS_PROTOCOL_RVGC_ID << 24) | 0xF00004)
 
 struct taurus_rvgc_ioc_display_init_in {
-    uint64_t    cookie;
-    uint32_t    display;
+	uint64_t    cookie;
+	uint32_t    display;
 } __packed;
 
 struct taurus_rvgc_ioc_display_init_out {
-    uint64_t    cookie;
-    uint64_t    res;
+	uint64_t    cookie;
+	uint64_t    res;
 } __packed;
 
 
 #define RVGC_PROTOCOL_IOC_DISPLAY_GET_INFO              ((TAURUS_PROTOCOL_RVGC_ID << 24) | 0xF00005)
 
 struct taurus_rvgc_ioc_display_get_info_in {
-    uint64_t    cookie;
-    uint32_t    display;
+	uint64_t    cookie;
+	uint32_t    display;
 } __packed;
 
 struct taurus_rvgc_ioc_display_get_info_out {
-    uint64_t    cookie;
-    uint64_t    res;
-    uint32_t    width;
-    uint32_t    height;
-    uint32_t    pitch;
-    uint32_t    layers;
+	uint64_t    cookie;
+	uint64_t    res;
+	uint32_t    width;
+	uint32_t    height;
+	uint32_t    pitch;
+	uint32_t    layers;
 } __packed;
 
 
 #define RVGC_PROTOCOL_IOC_LAYER_RESERVE                 ((TAURUS_PROTOCOL_RVGC_ID << 24) | 0xF00006)
 
 struct taurus_rvgc_ioc_layer_reserve_in {
-    uint64_t    cookie;
-    uint32_t    display;
-    uint32_t    layer;
+	uint64_t    cookie;
+	uint32_t    display;
+	uint32_t    layer;
 } __packed;
 
 struct taurus_rvgc_ioc_layer_reserve_out {
-    uint64_t    cookie;
-    uint64_t    res;
+	uint64_t    cookie;
+	uint64_t    res;
 } __packed;
 
 
 #define RVGC_PROTOCOL_IOC_LAYER_RELEASE                 ((TAURUS_PROTOCOL_RVGC_ID << 24) | 0xF00007)
 
 struct taurus_rvgc_ioc_layer_release_in {
-    uint64_t    cookie;
-    uint32_t    display;
-    uint32_t    layer;
+	uint64_t    cookie;
+	uint32_t    display;
+	uint32_t    layer;
 } __packed;
 
 struct taurus_rvgc_ioc_layer_release_out {
-    uint64_t    cookie;
-    uint64_t    res;
+	uint64_t    cookie;
+	uint64_t    res;
 } __packed;
 
 
 /*******************************************************/
 
 struct taurus_rvgc_cmd_msg {
-    R_TAURUS_CmdMsg_t   hdr;
-    uint32_t            type;
-    union {
-        struct taurus_rvgc_ioc_layer_set_addr_in ioc_layer_set_addr;
-        struct taurus_rvgc_ioc_layer_set_pos_in ioc_layer_set_pos;
-        struct taurus_rvgc_ioc_layer_set_size_in ioc_layer_set_size;
-        struct taurus_rvgc_ioc_layer_reserve_in ioc_layer_reserve;
-        struct taurus_rvgc_ioc_layer_release_in ioc_layer_release;
-        struct taurus_rvgc_ioc_display_flush_in ioc_display_flush;
-        struct taurus_rvgc_ioc_display_init_in ioc_display_init;
-        struct taurus_rvgc_ioc_display_get_info_in ioc_display_get_info;
-    } params;
+	R_TAURUS_CmdMsg_t   hdr;
+	uint32_t            type;
+	union {
+		struct taurus_rvgc_ioc_layer_set_addr_in ioc_layer_set_addr;
+		struct taurus_rvgc_ioc_layer_set_pos_in ioc_layer_set_pos;
+		struct taurus_rvgc_ioc_layer_set_size_in ioc_layer_set_size;
+		struct taurus_rvgc_ioc_layer_reserve_in ioc_layer_reserve;
+		struct taurus_rvgc_ioc_layer_release_in ioc_layer_release;
+		struct taurus_rvgc_ioc_display_flush_in ioc_display_flush;
+		struct taurus_rvgc_ioc_display_init_in ioc_display_init;
+		struct taurus_rvgc_ioc_display_get_info_in ioc_display_get_info;
+	} params;
 };
 
 struct taurus_rvgc_res_msg {
-    R_TAURUS_ResultMsg_t        hdr;
-    uint32_t                    type;
-    union {
-        struct taurus_rvgc_ioc_layer_set_addr_out ioc_layer_set_addr;
-        struct taurus_rvgc_ioc_layer_set_pos_out ioc_layer_set_pos;
-        struct taurus_rvgc_ioc_layer_set_size_out ioc_layer_set_size;
-        struct taurus_rvgc_ioc_layer_reserve_out ioc_layer_reserve;
-        struct taurus_rvgc_ioc_layer_release_out ioc_layer_release;
-        struct taurus_rvgc_ioc_display_flush_out ioc_display_flush;
-        struct taurus_rvgc_ioc_display_init_out ioc_display_init;
-        struct taurus_rvgc_ioc_display_get_info_out ioc_display_get_info;
-    } params;
+	R_TAURUS_ResultMsg_t        hdr;
+	uint32_t                    type;
+	union {
+		struct taurus_rvgc_ioc_layer_set_addr_out ioc_layer_set_addr;
+		struct taurus_rvgc_ioc_layer_set_pos_out ioc_layer_set_pos;
+		struct taurus_rvgc_ioc_layer_set_size_out ioc_layer_set_size;
+		struct taurus_rvgc_ioc_layer_reserve_out ioc_layer_reserve;
+		struct taurus_rvgc_ioc_layer_release_out ioc_layer_release;
+		struct taurus_rvgc_ioc_display_flush_out ioc_display_flush;
+		struct taurus_rvgc_ioc_display_init_out ioc_display_init;
+		struct taurus_rvgc_ioc_display_get_info_out ioc_display_get_info;
+	} params;
 };
 
 
diff --git a/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_drv.c b/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_drv.c
index 3c40012b2859..3ca9c769dea7 100644
--- a/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_drv.c
+++ b/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_drv.c
@@ -37,27 +37,26 @@
  * named "rcar-du".
  * We need to give the same name here, if we want to avoid any
  * changes to Android HWC */
-#define RCAR_RVGC_DRM_NAME	"rcar-du" /* "rcar-rvgc" */
-
+//#define RCAR_RVGC_DRM_NAME     "rcar-rvgc"
+#define RCAR_RVGC_DRM_NAME     "rcar-du"
+static bool update_primary_plane = 1;
+module_param(update_primary_plane, bool, 0);
 
 /* -----------------------------------------------------------------------------
  * RPMSG operations
  */
 
-static int rcar_rvgc_cb(struct rpmsg_device *rpdev, void *data, int len,
-			void *priv, u32 src)
-{
-	struct rcar_rvgc_device *rcrvgc = dev_get_drvdata(&rpdev->dev);
-	struct rcar_rvgc_pipe *rvgc_pipe;
-	unsigned int display_mapping;
-	struct taurus_event_list *event;
-	struct list_head *i;
-	struct taurus_rvgc_res_msg *res = (struct taurus_rvgc_res_msg*)data;
+static int rcar_rvgc_cb(struct rpmsg_device* rpdev, void* data, int len,
+			void* priv, u32 src) {
+	struct rcar_rvgc_device* rcrvgc = dev_get_drvdata(&rpdev->dev);
+	struct taurus_event_list* event;
+	struct list_head* i;
+	struct taurus_rvgc_res_msg* res = (struct taurus_rvgc_res_msg*)data;
 	uint32_t res_id = res->hdr.Id;
 
 	dev_dbg(&rpdev->dev, "%s():%d\n", __FUNCTION__, __LINE__);
 
-	if ((res->hdr.Result == R_TAURUS_CMD_NOP) && (res_id ==0)) {
+	if ((res->hdr.Result == R_TAURUS_CMD_NOP) && (res_id == 0)) {
 		/* This is an asynchronous signal sent from the
 		 * peripheral, and not an answer of a previously sent
 		 * command. Just process the signal and return.*/
@@ -65,28 +64,24 @@ static int rcar_rvgc_cb(struct rpmsg_device *rpdev, void *data, int len,
 		dev_dbg(&rpdev->dev, "Signal received! Aux = %llx\n", res->hdr.Aux);
 
 		switch (res->hdr.Aux) {
-		case RVGC_PROTOCOL_EVENT_VBLANK_DISPLAY0:
-			display_mapping = 0;
-			break;
-		case RVGC_PROTOCOL_EVENT_VBLANK_DISPLAY1:
-			display_mapping = 1;
-			break;
-		case RVGC_PROTOCOL_EVENT_VBLANK_DISPLAY2:
-			display_mapping = 2;
-			break;
-		case RVGC_PROTOCOL_EVENT_VBLANK_DISPLAY3:
-			display_mapping = 3;
-			break;
-		default:
-			/* event not recognized */
-			return 0;
+		  case RVGC_PROTOCOL_EVENT_VBLANK_DISPLAY0:
+			  set_bit(0, (long unsigned int*)&rcrvgc->vblank_pending);
+			  break;
+		  case RVGC_PROTOCOL_EVENT_VBLANK_DISPLAY1:
+			  set_bit(1, (long unsigned int*)&rcrvgc->vblank_pending);
+			  break;
+		  case RVGC_PROTOCOL_EVENT_VBLANK_DISPLAY2:
+			  set_bit(2, (long unsigned int*)&rcrvgc->vblank_pending);
+			  break;
+		  case RVGC_PROTOCOL_EVENT_VBLANK_DISPLAY3:
+			  set_bit(3, (long unsigned int*)&rcrvgc->vblank_pending);
+			  break;
+		  default:
+			  /* event not recognized */
+			  return 0;
 		}
 
-		rvgc_pipe = rvgc_pipe_find_by_display(rcrvgc, display_mapping);
-		if (rvgc_pipe) {
-			rvgc_pipe->vblank_pending = 1;
-			wake_up_interruptible(&rcrvgc->vblank_pending_wait_queue);
-		}
+		wake_up_interruptible(&rcrvgc->vblank_pending_wait_queue);
 
 		return 0;
 	}
@@ -100,13 +95,13 @@ static int rcar_rvgc_cb(struct rpmsg_device *rpdev, void *data, int len,
 
 			memcpy(event->result, data, len);
 
-			if(event->ack_received) {
+			if (event->ack_received) {
 				complete(&event->completed);
 			} else {
 				event->ack_received = 1;
 				complete(&event->ack);
 			}
-			break;
+			//break;
 		}
 	}
 	read_unlock(&rcrvgc->event_list_lock);
@@ -119,9 +114,8 @@ static int rcar_rvgc_cb(struct rpmsg_device *rpdev, void *data, int len,
  * DRM operations
  */
 
-static int rcar_rvgc_dumb_create(struct drm_file *file, struct drm_device *dev,
-				struct drm_mode_create_dumb *args)
-{
+static int rcar_rvgc_dumb_create(struct drm_file* file, struct drm_device* dev,
+				 struct drm_mode_create_dumb* args) {
 	unsigned int min_pitch = DIV_ROUND_UP(args->width * args->bpp, 8);
 	unsigned int align;
 
@@ -154,8 +148,6 @@ static struct drm_driver rcar_rvgc_driver = {
 	.desc			= "Renesas Virtual Graphics Card",
 	.date			= "20190408",
 	.fops			= &rcar_rvgc_fops,
-	.enable_vblank		= rcar_rvgc_crtc_enable_vblank,
-	.disable_vblank		= rcar_rvgc_crtc_disable_vblank,
 };
 
 
@@ -163,18 +155,14 @@ static struct drm_driver rcar_rvgc_driver = {
  * Platform driver
  */
 
-static void rcar_rvgc_remove(struct rpmsg_device *rpdev)
-{
-	struct rcar_rvgc_device *rcrvgc = dev_get_drvdata(&rpdev->dev);
-	struct drm_device *ddev = rcrvgc->ddev;
-	int i;
-
-	for (i = 0; i < rcrvgc->nr_rvgc_pipes; i++) {
-		if (!rcrvgc->rvgc_pipes[i].vsync_thread)
-			dev_warn(rcrvgc->dev, "vsync_thread is not running\n");
-		else
-			kthread_stop(rcrvgc->rvgc_pipes[i].vsync_thread);
-	}
+static void rcar_rvgc_remove(struct rpmsg_device* rpdev) {
+	struct rcar_rvgc_device* rcrvgc = dev_get_drvdata(&rpdev->dev);
+	struct drm_device* ddev = rcrvgc->ddev;
+
+	if (!rcrvgc->vsync_thread)
+		dev_warn(rcrvgc->dev, "vsync_thread is not running\n");
+	else
+		kthread_stop(rcrvgc->vsync_thread);
 
 	if (rcrvgc->ddev) {
 		drm_dev_unregister(ddev);
@@ -182,15 +170,13 @@ static void rcar_rvgc_remove(struct rpmsg_device *rpdev)
 		drm_mode_config_cleanup(ddev);
 		drm_dev_put(ddev);
 	}
-
 	return;
 }
 
-static int rcar_rvgc_probe(struct rpmsg_device *rpdev)
-{
-	struct rcar_rvgc_device *rcrvgc;
-	struct drm_device *ddev;
-	struct device_node *rvgc_node;
+static int rcar_rvgc_probe(struct rpmsg_device* rpdev) {
+	struct rcar_rvgc_device* rcrvgc;
+	struct drm_device* ddev;
+	struct device_node* rvgc_node;
 	int ret = 0;
 
 	printk(KERN_ERR "%s():%d\n", __FUNCTION__, __LINE__);
@@ -201,10 +187,15 @@ static int rcar_rvgc_probe(struct rpmsg_device *rpdev)
 		return -ENOMEM;
 
 	dev_set_drvdata(&rpdev->dev, rcrvgc);
+	rcrvgc->update_primary_plane = update_primary_plane;
 
 	/* Save a link to struct device and struct rpmsg_device */
 	rcrvgc->dev = &rpdev->dev;
 	rcrvgc->rpdev = rpdev;
+	/* TODO: store update_primary_plane parameter in driver struct */
+
+	/* Initialize vblank_pending state */
+	rcrvgc->vblank_pending = 0;
 
 	/* Initialize taurus event list and its lock */
 	INIT_LIST_HEAD(&rcrvgc->taurus_event_list_head);
@@ -271,7 +262,7 @@ static int rcar_rvgc_probe(struct rpmsg_device *rpdev)
 
 	return 0;
 
-error:
+ error:
 	rcar_rvgc_remove(rpdev);
 
 	return ret;
diff --git a/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_drv.h b/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_drv.h
index c42a15c6922d..e2b94882524a 100644
--- a/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_drv.h
+++ b/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_drv.h
@@ -21,7 +21,7 @@ struct taurus_rvgc_res_msg;
 
 struct taurus_event_list {
 	uint32_t id;
-	struct taurus_rvgc_res_msg *result;
+	struct taurus_rvgc_res_msg* result;
 	struct list_head list;
 	struct completion ack;
 	bool ack_received;
@@ -29,19 +29,29 @@ struct taurus_event_list {
 };
 
 struct rcar_rvgc_device {
-	struct device *dev;
+	struct device* dev;
 
-	struct drm_device *ddev;
+	struct drm_device* ddev;
 
-	struct rpmsg_device *rpdev;
+	struct rpmsg_device* rpdev;
 
 	unsigned int nr_rvgc_pipes;
-	struct rcar_rvgc_pipe *rvgc_pipes;
+	struct rcar_rvgc_pipe* rvgc_pipes;
 
+	/* needed for taurus configuration */
+	uint8_t vblank_pending;
 	wait_queue_head_t vblank_pending_wait_queue;
 
+	/* needed for drm communication */
+	wait_queue_head_t vblank_enable_wait_queue;
+	atomic_t global_vblank_enable;
+
+	struct task_struct* vsync_thread;
+
 	struct list_head taurus_event_list_head;
 	rwlock_t event_list_lock;
+
+	bool update_primary_plane;
 };
 
 #endif /* __RCAR_RVGC_DRV_H__ */
diff --git a/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_kms.c b/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_kms.c
index 378fe83c0bd1..adeef4739506 100644
--- a/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_kms.c
+++ b/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_kms.c
@@ -1,27 +1,20 @@
-#include <drm/drmP.h>
 #include <drm/drm_device.h>
 #include <drm/drm_atomic.h>
 #include <drm/drm_atomic_helper.h>
 #include <drm/drm_fb_cma_helper.h>
 #include <drm/drm_gem_framebuffer_helper.h>
+#include <drm/drm_vblank.h>
 
 #include <linux/kthread.h>
 #include <linux/delay.h>
 
 #include "rcar_rvgc_drv.h"
+#include "rcar_rvgc_kms.h"
 #include "rcar_rvgc_pipe.h"
 
 #include "rcar_rvgc_taurus.h"
 #include "r_taurus_rvgc_protocol.h"
 
-static wait_queue_head_t vblank_enable_wait_queue;
-
-struct rcar_rvgc_format_info {
-        u32 fourcc;
-        unsigned int bpp;
-        unsigned int planes;
-};
-
 /********** Fromat Info **********/
 static const struct rcar_rvgc_format_info rcar_rvgc_format_infos[] = {
 	{
@@ -35,8 +28,7 @@ static const struct rcar_rvgc_format_info rcar_rvgc_format_infos[] = {
 	},
 };
 
-const struct rcar_rvgc_format_info *rcar_rvgc_format_info(u32 fourcc)
-{
+const struct rcar_rvgc_format_info* rcar_rvgc_format_info(u32 fourcc) {
 	unsigned int i;
 
 	for (i = 0; i < ARRAY_SIZE(rcar_rvgc_format_infos); ++i) {
@@ -48,15 +40,14 @@ const struct rcar_rvgc_format_info *rcar_rvgc_format_info(u32 fourcc)
 }
 
 /********** DRM Framebuffer **********/
-static struct drm_framebuffer *rcar_rvgc_fb_create(struct drm_device *dev, struct drm_file *file_priv,
-							   const struct drm_mode_fb_cmd2 *mode_cmd)
-{
-	const struct rcar_rvgc_format_info *format;
+static struct drm_framebuffer* rcar_rvgc_fb_create(struct drm_device* dev, struct drm_file* file_priv,
+						   const struct drm_mode_fb_cmd2* mode_cmd) {
+	const struct rcar_rvgc_format_info* format;
 
 	format = rcar_rvgc_format_info(mode_cmd->pixel_format);
 	if (format == NULL) {
 		dev_dbg(dev->dev, "unsupported pixel format %08x\n",
-				mode_cmd->pixel_format);
+			mode_cmd->pixel_format);
 		return ERR_PTR(-EINVAL);
 	}
 
@@ -64,38 +55,50 @@ static struct drm_framebuffer *rcar_rvgc_fb_create(struct drm_device *dev, struc
 }
 
 /********** VBlank Handling **********/
-static int vsync_thread_fn(void *data)
-{
-	struct rcar_rvgc_pipe *rvgc_pipe = (struct rcar_rvgc_pipe *)data;
-	struct rcar_rvgc_device *rcrvgc = rvgc_pipe->rcar_rvgc_dev;
-	struct drm_crtc *crtc;
-	struct drm_pending_vblank_event *event;
+static int vsync_thread_fn(void* data) {
+	struct rcar_rvgc_device* rcrvgc = (struct rcar_rvgc_device*)data;
+	struct drm_crtc* crtc;
+	struct rcar_rvgc_pipe* rvgc_pipe;
+	unsigned int nr_rvgc_pipes = rcrvgc->nr_rvgc_pipes;
+	int i;
+	int pipe_vblk_pending;
+	unsigned int display_idx;
+	struct drm_pending_vblank_event* event;
 	unsigned long flags;
 
 	while (!kthread_should_stop()) {
 
-		wait_event_interruptible(vblank_enable_wait_queue, atomic_read(&rvgc_pipe->global_vblank_enable));
+		wait_event_interruptible(rcrvgc->vblank_enable_wait_queue, atomic_read(&rcrvgc->global_vblank_enable));
+		/* TODO: Check if possible problem here ? Only one wait line needed maybe. */
+		wait_event_interruptible(rcrvgc->vblank_pending_wait_queue, rcrvgc->vblank_pending);
 
-		wait_event_interruptible(rcrvgc->vblank_pending_wait_queue, rvgc_pipe->vblank_pending);
+		for (i = 0; i < nr_rvgc_pipes; i++) {
+			rvgc_pipe = &rcrvgc->rvgc_pipes[i];
+			display_idx = rvgc_pipe->display_mapping;
+			;
 
-		rvgc_pipe->vblank_pending = 0;
+			pipe_vblk_pending = test_and_clear_bit(display_idx, (long unsigned int*)&rcrvgc->vblank_pending);
 
-		if (rvgc_pipe->vblank_enabled) {
-			crtc = &rvgc_pipe->drm_simple_pipe.crtc;
+			if (pipe_vblk_pending && rvgc_pipe->vblank_enabled) {
+				/* TODO: removed simple pipe here nothing else need to be done here */
+				crtc = &rvgc_pipe->crtc;
 
-			drm_crtc_handle_vblank(crtc);
+				drm_crtc_handle_vblank(crtc);
 
-			spin_lock_irqsave(&crtc->dev->event_lock, flags);
-			event = rvgc_pipe->event;
-			rvgc_pipe->event = NULL;
-			spin_unlock_irqrestore(&crtc->dev->event_lock, flags);
+				spin_lock_irqsave(&crtc->dev->event_lock, flags);
+				event = rvgc_pipe->event;
+				rvgc_pipe->event = NULL;
+				spin_unlock_irqrestore(&crtc->dev->event_lock, flags);
+
+				if (event == NULL)
+					continue;
 
-			if (event != NULL) {
 				spin_lock_irqsave(&crtc->dev->event_lock, flags);
 				drm_crtc_send_vblank_event(crtc, event);
 				spin_unlock_irqrestore(&crtc->dev->event_lock, flags);
 
-				drm_crtc_vblank_put(crtc);
+				/* JMB: Where is corresponding "get" ? */
+				// drm_crtc_vblank_put(crtc);
 			}
 		}
 	}
@@ -104,39 +107,8 @@ static int vsync_thread_fn(void *data)
 	return 0;
 }
 
-int rcar_rvgc_crtc_enable_vblank(struct drm_device *dev, unsigned int pipe)
-{
-	int ret = 0;
-	struct drm_crtc *crtc = drm_crtc_from_index(dev, pipe);
-	struct drm_simple_display_pipe *drm_simple_pipe = container_of(crtc, struct drm_simple_display_pipe, crtc);
-	struct rcar_rvgc_pipe *rvgc_pipe = container_of(drm_simple_pipe, struct rcar_rvgc_pipe, drm_simple_pipe);
-
-	dev_dbg(dev->dev, "%s(%d)\n", __FUNCTION__, pipe);
-
-	rvgc_pipe->vblank_enabled = 1;
-	atomic_inc(&rvgc_pipe->global_vblank_enable);
-	wake_up_interruptible(&vblank_enable_wait_queue);
-
-	return ret;
-}
-
-void rcar_rvgc_crtc_disable_vblank(struct drm_device *dev, unsigned int pipe)
-{
-	struct drm_crtc *crtc = drm_crtc_from_index(dev, pipe);
-	struct drm_simple_display_pipe *drm_simple_pipe = container_of(crtc, struct drm_simple_display_pipe, crtc);
-	struct rcar_rvgc_pipe *rvgc_pipe = container_of(drm_simple_pipe, struct rcar_rvgc_pipe, drm_simple_pipe);
-
-	dev_dbg(dev->dev, "%s(%d)\n", __FUNCTION__, pipe);
-
-	rvgc_pipe->vblank_enabled = 0;
-	atomic_dec(&rvgc_pipe->global_vblank_enable);
-	WARN_ON(atomic_read(&rvgc_pipe->global_vblank_enable) < 0);
-	return;
-}
-
-static void rcar_rvgc_atomic_commit_tail(struct drm_atomic_state *old_state)
-{
-	struct drm_device *dev = old_state->dev;
+static void rcar_rvgc_atomic_commit_tail(struct drm_atomic_state* old_state) {
+	struct drm_device* dev = old_state->dev;
 
 	/* Apply the atomic update. */
 	drm_atomic_helper_commit_modeset_disables(dev, old_state);
@@ -156,16 +128,16 @@ static const struct drm_mode_config_funcs rcar_rvgc_mode_config_funcs = {
 };
 
 static const struct drm_mode_config_helper_funcs rcar_rvgc_mode_config_helper = {
-        .atomic_commit_tail = rcar_rvgc_atomic_commit_tail,
+	.atomic_commit_tail = rcar_rvgc_atomic_commit_tail,
 };
 
-int rcar_rvgc_modeset_init(struct rcar_rvgc_device *rcrvgc)
-{
-	struct drm_device *dev = rcrvgc->ddev;
-	struct device_node *dt_node;
-	u32 nr_rvgc_pipes;
+int rcar_rvgc_modeset_init(struct rcar_rvgc_device* rcrvgc) {
+	struct drm_device* dev = rcrvgc->ddev;
+	struct device_node* displays_node;
+	struct device_node* display_node;
 	int ret = 0;
-	int i;
+	int display;
+	int layer;
 
 	drm_mode_config_init(dev);
 
@@ -175,87 +147,126 @@ int rcar_rvgc_modeset_init(struct rcar_rvgc_device *rcrvgc)
 	dev->mode_config.max_height = 2160;
 	dev->mode_config.funcs = &rcar_rvgc_mode_config_funcs;
 	dev->mode_config.helper_private = &rcar_rvgc_mode_config_helper;
+	/* have drm_atomic_helper_check normalize zpos */
+	dev->mode_config.normalize_zpos = true;
 
-	dt_node = of_find_node_by_path("/rvgc");
-	if (!dt_node) {
-		dev_err(rcrvgc->dev, "Cannot find devicetree node \"/rvgc\"\n");
+	displays_node = of_find_node_by_path("/rvgc/displays");
+	if (!displays_node) {
+		dev_err(rcrvgc->dev, "Cannot find devicetree node \"/rvgc/displays\"\n");
 		ret = -EINVAL;
 		goto exit;
 	}
 
-	ret = of_property_read_u32(dt_node, "nr-displays", &nr_rvgc_pipes);
-	if (ret) {
-		dev_err(rcrvgc->dev, "can't read property \"nr-displays\" in node \"/rvgc\"\n");
-		ret = -EINVAL;
-		goto exit;
+	/* count display nodes */
+	rcrvgc->nr_rvgc_pipes = 0;
+	for_each_child_of_node(displays_node, display_node) {
+		rcrvgc->nr_rvgc_pipes++;
 	}
 
-	rcrvgc->nr_rvgc_pipes = nr_rvgc_pipes;
-	rcrvgc->rvgc_pipes = kzalloc(sizeof(struct rcar_rvgc_pipe) * nr_rvgc_pipes, GFP_KERNEL);
+	rcrvgc->rvgc_pipes = kzalloc(sizeof(struct rcar_rvgc_pipe) * rcrvgc->nr_rvgc_pipes, GFP_KERNEL);
 	if (!rcrvgc->rvgc_pipes)
 		return -ENOMEM;
-	for (i = 0; i < nr_rvgc_pipes; i++) {
-		rcrvgc->rvgc_pipes[i].vblank_pending = 0;
-		atomic_set(&rcrvgc->rvgc_pipes[i].global_vblank_enable, 0);
-	}
 
 	dev_info(rcrvgc->dev, "Number of virtual displays = %u\n", rcrvgc->nr_rvgc_pipes);
 
 	/*
 	 * Initialize display pipes
 	 */
-	for  (i=0; i<nr_rvgc_pipes ; i++) {
-		struct rcar_rvgc_pipe *rvgc_pipe = &rcrvgc->rvgc_pipes[i];
-		rvgc_pipe->idx = i;
+	display = 0;
+	for_each_child_of_node(displays_node, display_node) {
+		struct rcar_rvgc_pipe* rvgc_pipe = &rcrvgc->rvgc_pipes[display];
+		struct device_node* layers_node;
+		struct device_node* layer_node;
+
+		rvgc_pipe->idx = display;
 
-		ret = of_property_read_u32_index(dt_node, "display-mappings", i, &rvgc_pipe->display_mapping);
+		ret = of_property_read_u32(display_node, "display-map", &rvgc_pipe->display_mapping);
 		if (ret) {
-			dev_err(rcrvgc->dev, "can't read value in \"display-mappings\" index = %d\n", i);
+			dev_err(rcrvgc->dev, "can't read value in \"display-map\" display = %d\n", display);
 			ret = -EINVAL;
 			goto exit;
 		}
 
-		ret = of_property_read_u32_index(dt_node, "display-layer", i, &rvgc_pipe->display_layer);
-		if (ret) {
-			dev_err(rcrvgc->dev, "can't read value in \"display-layer\" index = %d. Using default (4)\n", i);
-			rvgc_pipe->display_layer = 4;
+		layers_node = of_get_child_by_name(display_node, "layers");
+		if (!layers_node) {
+			dev_err(rcrvgc->dev, "Cannot find display %d \"layers\" node\n", display);
+			ret = -EINVAL;
+			goto exit;
 		}
 
+		rvgc_pipe->plane_nr = 0;
+		for_each_child_of_node(layers_node, layer_node) {
+			rvgc_pipe->plane_nr++;
+		}
+
+		rvgc_pipe->planes = devm_kzalloc(rcrvgc->dev, sizeof(rvgc_pipe->planes[0]) * rvgc_pipe->plane_nr, GFP_KERNEL);
+
 		ret = rcar_rvgc_pipe_init(rcrvgc, rvgc_pipe);
 		if (ret) {
-			dev_err(rcrvgc->dev, "Pipe %d init failed: %d\n", i, ret);
+			dev_err(rcrvgc->dev, "Pipe %d init failed: %d\n", display, ret);
 			goto exit;
 		}
+
+		layer = 0;
+		for_each_child_of_node(layers_node, layer_node) {
+			struct rcar_rvgc_plane* cur_plane = &rvgc_pipe->planes[layer];
+			
+			of_property_read_u32(layer_node, "layer-map", &cur_plane->hw_plane);
+			cur_plane->no_scan = of_property_read_bool(layer_node, "no-scan");
+			cur_plane->size_override = of_property_read_bool(layer_node, "size-override");
+			if (of_property_read_u32(layer_node, "size-w", &cur_plane->size_w))
+				cur_plane->size_w = rvgc_pipe->display_width;
+			if (of_property_read_u32(layer_node, "size-h", &cur_plane->size_h))
+				cur_plane->size_h = rvgc_pipe->display_height;
+			cur_plane->pos_override = of_property_read_bool(layer_node, "pos-override");
+			of_property_read_u32(layer_node, "pos-x", &cur_plane->pos_x);
+			of_property_read_u32(layer_node, "pos-y", &cur_plane->pos_y);
+			layer++;
+		}
+
+		display++;
 	}
 
-	init_waitqueue_head(&vblank_enable_wait_queue);
+	init_waitqueue_head(&rcrvgc->vblank_enable_wait_queue);
+	rcrvgc->global_vblank_enable = (atomic_t)ATOMIC_INIT(0);
+
+	if (rcrvgc->vsync_thread)
+		dev_warn(rcrvgc->dev, "vsync_thread is already running\n");
+	else
+		rcrvgc->vsync_thread = kthread_run(vsync_thread_fn,
+						   rcrvgc,
+						   "rvgc_vsync kthread");
+
 
 	/*
 	 * Initialize vertical blanking interrupts handling. Start with vblank
 	 * disabled for all CRTCs.
 	 */
-	ret = drm_vblank_init(dev, nr_rvgc_pipes);
+	ret = drm_vblank_init(dev, rcrvgc->nr_rvgc_pipes);
 	if (ret < 0) {
 		dev_err(rcrvgc->dev, "drm_vblank_init failed: %d\n", ret);
 		goto exit;
 	}
-	for  (i=0; i<nr_rvgc_pipes ; i++) {
-		struct rcar_rvgc_pipe *rvgc_pipe = &rcrvgc->rvgc_pipes[i];
-		drm_crtc_vblank_off(&rvgc_pipe->drm_simple_pipe.crtc);
+	for  (layer = 0; layer < rcrvgc->nr_rvgc_pipes; layer++) {
+		struct rcar_rvgc_pipe* rvgc_pipe = &rcrvgc->rvgc_pipes[layer];
+		drm_crtc_vblank_off(&rvgc_pipe->crtc);
 	}
 
 	/* Reset crtcs, encoders and connectors */
 	drm_mode_config_reset(dev);
 
-	for  (i=0; i < nr_rvgc_pipes; i++) {
-		if (rcrvgc->rvgc_pipes[i].vsync_thread)
-			dev_warn(rcrvgc->dev, "vsync_thread is already running\n");
-		else
-			rcrvgc->rvgc_pipes[i].vsync_thread = kthread_run(vsync_thread_fn,
-							&rcrvgc->rvgc_pipes[i],
-							"rvgc_vsync kthread");
+	/* Add zpos after structures initialized, but before CRT inits...
+	   having tough time finding place where normalized zpos correctly init */
+	for (display = 0; display < rcrvgc->nr_rvgc_pipes; display++) {
+		struct rcar_rvgc_pipe* rvgc_pipe = &rcrvgc->rvgc_pipes[display];
+		for (layer = 0;
+		     layer < rvgc_pipe->plane_nr;
+		     layer++) {
+			struct rcar_rvgc_plane* cur_plane = &rvgc_pipe->planes[layer];
+			drm_plane_create_zpos_immutable_property(&cur_plane->plane, cur_plane->hw_plane);
+		}
 	}
 
-exit:
+ exit:
 	return ret;
 }
diff --git a/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_kms.h b/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_kms.h
index 9fab5539b93b..730b829e8701 100644
--- a/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_kms.h
+++ b/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_kms.h
@@ -14,13 +14,12 @@ struct rcar_rvgc_format_info {
 	unsigned int planes;
 };
 
-const struct rcar_rvgc_format_info *rcar_rvgc_format_info(u32 fourcc);
+const struct rcar_rvgc_format_info* rcar_rvgc_format_info(u32 fourcc);
 
-int rcar_rvgc_modeset_init(struct rcar_rvgc_device *rcrvgc);
+int rcar_rvgc_modeset_init(struct rcar_rvgc_device* rcrvgc);
 
-int rcar_rvgc_async_commit(struct drm_device *dev, struct drm_crtc *crtc);
-
-int rcar_rvgc_crtc_enable_vblank(struct drm_device *dev, unsigned int pipe);
-void rcar_rvgc_crtc_disable_vblank(struct drm_device *dev, unsigned int pipe);
+int rcar_rvgc_async_commit(struct drm_device* dev, struct drm_crtc* crtc);
+int rcar_rvgc_crtc_enable_vblank(struct drm_device* dev, unsigned int pipe);
+void rcar_rvgc_crtc_disable_vblank(struct drm_device* dev, unsigned int pipe);
 
 #endif /* __RCAR_RVGC_KMS_H__ */
diff --git a/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_pipe.c b/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_pipe.c
index af1dd83d906a..257cef02730b 100644
--- a/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_pipe.c
+++ b/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_pipe.c
@@ -1,15 +1,17 @@
-#include <drm/drmP.h>
 #include <drm/drm_device.h>
 
 #include "rcar_rvgc_drv.h"
 #include "rcar_rvgc_pipe.h"
 #include <drm/drm_simple_kms_helper.h>
+#include <drm/drm_atomic.h>
 #include <drm/drm_atomic_helper.h>
 #include <drm/drm_crtc.h>
 #include <drm/drm_crtc_helper.h>
 #include <drm/drm_fb_cma_helper.h>
 #include <drm/drm_gem_cma_helper.h>
 #include <drm/drm_gem_framebuffer_helper.h>
+#include <drm/drm_vblank.h>
+#include <drm/drm_drv.h>
 #include <drm/drm_probe_helper.h>
 
 #include "rcar_rvgc_taurus.h"
@@ -18,39 +20,24 @@
 
 struct rvgc_connector {
 	struct drm_connector base;
-	struct rcar_rvgc_device *rvgc_dev;
+	struct rcar_rvgc_device* rvgc_dev;
 	unsigned int pipe_idx;
-	struct drm_display_mode *mode;
+	struct drm_display_mode* mode;
 };
 
 
-static inline struct rvgc_connector *
-to_rvgc_connector(struct drm_connector *connector)
-{
+static inline struct rvgc_connector*
+to_rvgc_connector(struct drm_connector* connector) {
 	return container_of(connector, struct rvgc_connector, base);
 }
 
-static int rvgc_connector_get_modes(struct drm_connector *connector)
-{
-	struct rvgc_connector *rconn = to_rvgc_connector(connector);
-	struct rcar_rvgc_device *rvgc_dev = rconn->rvgc_dev;
-	struct rcar_rvgc_pipe *rvgc_pipe = &rvgc_dev->rvgc_pipes[rconn->pipe_idx];
-	struct drm_display_mode *mode;
+static int rvgc_connector_get_modes(struct drm_connector* connector) {
+	struct rvgc_connector* rconn = to_rvgc_connector(connector);
+	struct rcar_rvgc_device* rvgc_dev = rconn->rvgc_dev;
+	struct rcar_rvgc_pipe* rvgc_pipe = &rvgc_dev->rvgc_pipes[rconn->pipe_idx];
+	struct drm_display_mode* mode;
 
 	if (!rconn->mode) {
-		struct taurus_rvgc_res_msg res_msg;
-		int ret;
-
-		ret = rvgc_taurus_display_get_info(rvgc_dev,
-						rvgc_pipe->display_mapping,
-						&res_msg);
-		if (ret) {
-			dev_err(rvgc_dev->dev, "%s(): rvgc_taurus_display_get_info(%d) failed\n",
-				__FUNCTION__,
-				rvgc_pipe->display_mapping);
-			return ret;
-		}
-
 		rconn->mode = drm_mode_create(rvgc_dev->ddev);
 		if (!rconn->mode) {
 			dev_err(rvgc_dev->dev,
@@ -58,9 +45,9 @@ static int rvgc_connector_get_modes(struct drm_connector *connector)
 				__FUNCTION__);
 			return 0;
 		}
-
-		rconn->mode->hdisplay = res_msg.params.ioc_display_get_info.width;
-		rconn->mode->vdisplay = res_msg.params.ioc_display_get_info.height;
+		/* The first device tree plane is the primary plane (use its dimensions) */
+		rconn->mode->hdisplay = rvgc_pipe->planes[0].size_w;
+		rconn->mode->vdisplay = rvgc_pipe->planes[0].size_h;
 
 		/* The following memebers in struct drm_display_mode
 		 * are set to some fake values just to make the
@@ -100,17 +87,15 @@ static const struct drm_connector_helper_funcs rvgc_connector_hfuncs = {
 };
 
 static enum drm_connector_status
-rvgc_connector_detect(struct drm_connector *connector, bool force)
-{
+rvgc_connector_detect(struct drm_connector* connector, bool force) {
 	if (drm_dev_is_unplugged(connector->dev))
 		return connector_status_disconnected;
 
 	return connector->status;
 }
 
-static void rvgc_connector_destroy(struct drm_connector *connector)
-{
-	struct rvgc_connector *rconn = to_rvgc_connector(connector);
+static void rvgc_connector_destroy(struct drm_connector* connector) {
+	struct rvgc_connector* rconn = to_rvgc_connector(connector);
 
 	drm_connector_cleanup(connector);
 	kfree(rconn);
@@ -125,13 +110,13 @@ static const struct drm_connector_funcs rvgc_connector_funcs = {
 	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
 };
 
-struct drm_connector *
-rvgc_connector_create(struct rcar_rvgc_pipe *rvgc_pipe)
+static struct drm_connector
+*rvgc_connector_create(struct rcar_rvgc_pipe *rvgc_pipe)
 {
-	struct rcar_rvgc_device *rvgc_dev = rvgc_pipe->rcar_rvgc_dev;
-	struct drm_device *drm = rvgc_dev->ddev;
-	struct rvgc_connector *rconn;
-	struct drm_connector *connector;
+	struct rcar_rvgc_device* rvgc_dev = rvgc_pipe->rcar_rvgc_dev;
+	struct drm_device* drm = rvgc_dev->ddev;
+	struct rvgc_connector* rconn;
+	struct drm_connector* connector;
 	int ret;
 	int connector_type = DRM_MODE_CONNECTOR_HDMIA;
 
@@ -156,82 +141,89 @@ rvgc_connector_create(struct rcar_rvgc_pipe *rvgc_pipe)
 	return connector;
 }
 
-static void rvgc_pipe_enable(struct drm_simple_display_pipe *pipe,
-			struct drm_crtc_state *crtc_state, struct drm_plane_state *plane_state)
-{
-	struct device *ddev = pipe->plane.dev->dev;
-	struct rcar_rvgc_pipe *rvgc_pipe = container_of(pipe, struct rcar_rvgc_pipe, drm_simple_pipe);
-	dev_dbg(ddev, "%s() rvgc_pipe = %d\n", __FUNCTION__, rvgc_pipe->idx);
-	drm_crtc_vblank_on(&pipe->crtc);
+static const u32 rvgc_formats[] = {
+	DRM_FORMAT_XRGB8888,
+	DRM_FORMAT_ARGB8888,
+};
+
+static const struct drm_encoder_funcs drm_simple_kms_encoder_funcs = {
+	.destroy = drm_encoder_cleanup,
+};
+
+static int rvgc_crtc_check(struct drm_crtc* crtc,
+			   struct drm_crtc_state* state) {
+	bool has_primary = state->plane_mask &
+		BIT(drm_plane_index(crtc->primary));
+
+	/* We always want to have an active plane with an active CRTC */
+	if (has_primary != state->enable)
+		return -EINVAL;
+
+	return drm_atomic_add_affected_planes(state->state, crtc);
 }
 
-static void rvgc_pipe_disable(struct drm_simple_display_pipe *pipe)
+static int rvgc_crtc_enable_vblank(struct drm_crtc* crtc) {  /* TODO: Check that new vblank will be enabled and old remove */
+	int ret = 0;
+	struct rcar_rvgc_pipe* rvgc_pipe = container_of(crtc, struct rcar_rvgc_pipe, crtc);
+	struct rcar_rvgc_device* rcrvgc = rvgc_pipe->rcar_rvgc_dev;
+
+	//printk(KERN_ERR "%s():%d", __FUNCTION__, __LINE__);
+
+	rvgc_pipe->vblank_enabled = 1;
+	atomic_inc(&rcrvgc->global_vblank_enable);
+	wake_up_interruptible(&rcrvgc->vblank_enable_wait_queue);
+
+	return ret;
+}
+
+static void rvgc_crtc_disable_vblank(struct drm_crtc* crtc) { /* TODO: Check that new vblank will be enabled and old remove */
+	struct rcar_rvgc_pipe* rvgc_pipe = container_of(crtc, struct rcar_rvgc_pipe, crtc);
+	struct rcar_rvgc_device* rcrvgc = rvgc_pipe->rcar_rvgc_dev;
+
+	//printk(KERN_ERR "%s():%d", __FUNCTION__, __LINE__);
+
+	rvgc_pipe->vblank_enabled = 0;
+	atomic_dec(&rcrvgc->global_vblank_enable);
+	WARN_ON(atomic_read(&rcrvgc->global_vblank_enable) < 0);
+	return;
+}
+
+
+static void rvgc_crtc_enable(struct drm_crtc* crtc,
+			     struct drm_crtc_state* old_state) {
+	//printk(KERN_ERR "%s():%d", __FUNCTION__, __LINE__);
+	drm_crtc_vblank_on(crtc);
+	drm_crtc_vblank_get(crtc);
+}
+
+static void rvgc_crtc_disable(struct drm_crtc *crtc,
+			      struct drm_crtc_state *old_state)
 {
-	struct device *ddev = pipe->plane.dev->dev;
-	struct rcar_rvgc_pipe *rvgc_pipe = container_of(pipe, struct rcar_rvgc_pipe, drm_simple_pipe);
-	dev_dbg(ddev, "%s() rvgc_pipe = %d\n", __FUNCTION__, rvgc_pipe->idx);
-	drm_crtc_vblank_off(&pipe->crtc);
+	//printk(KERN_ERR "%s():%d", __FUNCTION__, __LINE__);
+	drm_crtc_vblank_off(crtc);
+	drm_crtc_vblank_put(crtc);
 }
 
-static void rvgc_display_pipe_update(struct drm_simple_display_pipe *pipe,
-				struct drm_plane_state *old_state)
+static void rvgc_crtc_atomic_flush(struct drm_crtc *crtc,
+				   struct drm_crtc_state *old_crtc_state)
 {
-	struct drm_gem_cma_object *gem_obj;
 	int ret;
-	struct taurus_rvgc_res_msg res_msg;
-
-	struct drm_plane_state *new_plane_state = pipe->plane.state;
-	struct drm_crtc *crtc = &pipe->crtc;
-	struct device *dev = pipe->plane.dev->dev;
-	struct rcar_rvgc_device *rcrvgc = dev_get_drvdata(dev);
-	struct rcar_rvgc_pipe *rvgc_pipe = container_of(pipe, struct rcar_rvgc_pipe, drm_simple_pipe);
-	unsigned int display_idx = rvgc_pipe->display_mapping;
-	unsigned int display_layer = rvgc_pipe->display_layer;
+	struct rcar_rvgc_pipe* rvgc_pipe = container_of(crtc, struct rcar_rvgc_pipe, crtc);
+	struct rcar_rvgc_device* rcrvgc    = rvgc_pipe->rcar_rvgc_dev;
 	unsigned long flags;
+	struct taurus_rvgc_res_msg res_msg;
 
-	struct drm_pending_vblank_event *event;
-
-	/* No need to notify the Taurus server. Just send the vblank
-	 * event to notify the DRM that the commit is completed. */
-	if (crtc->state->active_changed || (new_plane_state->fb == old_state->fb)) {
+	/* Save the event in the rvgc_pipe struct so that we can send
+	 * it as soon as the Taurus notifies us. */
+	if (crtc->state->event) {
 		spin_lock_irqsave(&crtc->dev->event_lock, flags);
-		drm_crtc_send_vblank_event(crtc, crtc->state->event);
+		rvgc_pipe->event = crtc->state->event;
 		crtc->state->event = NULL;
 		spin_unlock_irqrestore(&crtc->dev->event_lock, flags);
-		return;
-	}
-
-	/* Update the framebuffer address */
-	if (new_plane_state->fb) {
-
-		gem_obj = drm_fb_cma_get_gem_obj(new_plane_state->fb, 0); //we support only single planar formats
-
-		ret = rvgc_taurus_layer_set_addr(rcrvgc,
-						display_idx,
-						display_layer,
-						gem_obj->paddr,
-						&res_msg);
-		if (ret) {
-			dev_err(rcrvgc->dev, "%s(): rvgc_taurus_layer_set_addr(display=%d, layer=%d) failed\n",
-				__FUNCTION__,
-				rvgc_pipe->display_mapping,
-				0);
-			return;
-		}
 	}
-
-	/* Save the event in the rvgc_pipe struct so that we can send
-	 * it as soon as the Taurus notifies us. */
-	drm_crtc_vblank_get(&pipe->crtc);
-
-	spin_lock_irqsave(&crtc->dev->event_lock, flags);
-	rvgc_pipe->event = crtc->state->event;
-	crtc->state->event = NULL;
-	spin_unlock_irqrestore(&crtc->dev->event_lock, flags);
-
 	/* Ask the Taurus server to flush the changes */
 	ret = rvgc_taurus_display_flush(rcrvgc,
-					display_idx,
+					rvgc_pipe->display_mapping,
 					0,
 					&res_msg);
 	if (ret) {
@@ -239,72 +231,275 @@ static void rvgc_display_pipe_update(struct drm_simple_display_pipe *pipe,
 			__FUNCTION__,
 			rvgc_pipe->display_mapping);
 	}
+}
 
-	spin_lock_irqsave(&crtc->dev->event_lock, flags);
-	event = rvgc_pipe->event;
-	rvgc_pipe->event = NULL;
-	spin_unlock_irqrestore(&crtc->dev->event_lock, flags);
+static const struct drm_crtc_helper_funcs rvgc_crtc_helper_funcs = {
+	.atomic_check = rvgc_crtc_check,
+	.atomic_enable = rvgc_crtc_enable,
+	.atomic_disable = rvgc_crtc_disable,
+	.atomic_flush = rvgc_crtc_atomic_flush,
+};
+
+static const struct drm_crtc_funcs rvgc_crtc_funcs = {
+	.reset = drm_atomic_helper_crtc_reset,
+	.destroy = drm_crtc_cleanup,
+	.set_config = drm_atomic_helper_set_config,
+	.page_flip = drm_atomic_helper_page_flip,
+	.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,
+	.enable_vblank = rvgc_crtc_enable_vblank,
+	.disable_vblank = rvgc_crtc_disable_vblank,
+};
+
+static int rvgc_plane_atomic_check(struct drm_plane* plane,
+				   struct drm_plane_state* plane_state) {
+	struct rcar_rvgc_plane* rvgc_plane = container_of(plane, struct rcar_rvgc_plane, plane);
+	struct rcar_rvgc_pipe* rvgc_pipe = rvgc_plane->pipe;
+	struct drm_crtc_state* crtc_state;
+
+	crtc_state = drm_atomic_get_new_crtc_state(plane_state->state,
+						   &rvgc_pipe->crtc);
+	if (!crtc_state || !crtc_state->enable)
+		return 0; /* nothing to check when disabling or disabled */
+
+	if (plane_state->fb)
+		plane_state->visible = true;
+	else
+		plane_state->visible = false;
+
+	return 0;
+}
 
-	if (event != NULL) {
+#if 0
+static int plane_not_changed_drm_send_event(struct drm_plane* plane,
+					    struct drm_plane_state* old_state) {
+	struct drm_plane_state* new_plane_state = plane->state;
+	struct rcar_rvgc_plane* rvgc_plane      = container_of(plane, struct rcar_rvgc_plane,
+							       plane);
+	struct rcar_rvgc_pipe* rvgc_pipe       = rvgc_plane->pipe;
+	struct drm_crtc* crtc            = &rvgc_pipe->crtc;
+	unsigned long flags = 0;
+	/* No need to notify the Taurus server. Just send the vblank
+	     * event to notify the DRM that the commit is completed. */
+	if (crtc->state->active_changed || (new_plane_state->fb == old_state->fb)) {
 		spin_lock_irqsave(&crtc->dev->event_lock, flags);
-		drm_crtc_send_vblank_event(crtc, event);
+		if (NULL == crtc->state->event) {
+			pr_err("[rvgc_drm] %s():%d", __FUNCTION__, __LINE__);
+		} else {
+			drm_crtc_send_vblank_event(crtc, crtc->state->event);
+		}
+		crtc->state->event = NULL;
 		spin_unlock_irqrestore(&crtc->dev->event_lock, flags);
+		return 1;
+	}
+	return 0;
+}
+
+static int check_refresh_primary(struct drm_plane* plane) {
+	enum drm_plane_type      plane_type      = plane->type;
+	struct device* ddev            = plane->dev->dev;
+	struct rcar_rvgc_device* rcrvgc          = dev_get_drvdata(ddev);
+	return ((plane_type == DRM_PLANE_TYPE_PRIMARY) && !rcrvgc->update_primary_plane);
+}
+#endif
+
+static void rvgc_plane_atomic_update(struct drm_plane* plane,
+				     struct drm_plane_state* old_state) {
+	struct drm_gem_cma_object* gem_obj;
+	struct taurus_rvgc_res_msg res_msg;
+
+	struct drm_framebuffer* fb              = plane->state->fb;
+	struct rcar_rvgc_plane* rvgc_plane      = container_of(plane, struct rcar_rvgc_plane,
+							       plane);
+	struct rcar_rvgc_pipe* rvgc_pipe       = rvgc_plane->pipe;
+	struct rcar_rvgc_device* rcrvgc          = rvgc_pipe->rcar_rvgc_dev;
+	unsigned int             display_idx     = rvgc_pipe->display_mapping;
+	int hw_plane;
+	bool pos_z_via_pvr = false;
+	int pos_x,pos_y,size_w,size_h;
+	int ret = 0;
+
+	/* Accomodate as many use case as possible by fdt/powervr.ini overrides */
+	if (rvgc_plane->no_scan) {
+		if (!old_state->fb && plane->state->fb) {
+			dev_info(rcrvgc->dev, "id=%d is NOT being displayed (FDT has no-scan)\n", plane->base.id);
+		}
+	} else {
+		pos_x = (rvgc_plane->pos_override) ? rvgc_plane->pos_x : plane->state->crtc_x;
+		pos_y = (rvgc_plane->pos_override) ? rvgc_plane->pos_y : plane->state->crtc_y;
+		size_w = (rvgc_plane->size_override) ? rvgc_plane->size_w : plane->state->crtc_w;
+		size_h = (rvgc_plane->size_override) ? rvgc_plane->size_h : plane->state->crtc_h;
+
+		/* check if we've encoded z layer in the powervr.ini pos_y */
+		if (0x00100000 == (pos_y & 0xFFF00000)) {
+			hw_plane = (pos_y & 0x000F0000)>>16;
+			pos_y = (int)((int16_t)(pos_y & 0xFFFF));
+			pos_z_via_pvr = true;
+		} else {
+			/* zpos is being normalized by drm_atomic_helper_check
+			   ...or should be anyhow :( */
+			//hw_plane = plane->state->normalized_zpos;
+			hw_plane = plane->state->zpos;
+		}
+
+		/* determine why we're here...*/
+		if (!old_state->fb && plane->state->fb) {
+			dev_info(rcrvgc->dev, "Reserve id=%d, layer=%d (via %s):%sx=%d, y=%d, %sw=%d, h=%d\n",
+				 plane->base.id, hw_plane, (pos_z_via_pvr) ? "PVR":"FDT",
+				 (rvgc_plane->pos_override) ? "Force Pos,":"", pos_x, pos_y,
+				 (rvgc_plane->size_override) ? "Force Size,":"", size_w, size_h);
+			/* enabling */
+			ret = rvgc_taurus_plane_reserve(rcrvgc,
+							display_idx,
+							hw_plane,
+							&res_msg);
+			if (ret) {
+				dev_err(rcrvgc->dev, "%s(): rvgc_taurus_plane_reserve(display=%d, id=%d, layer=%d) failed\n",
+					__FUNCTION__, display_idx, plane->base.id, hw_plane);
+				rvgc_plane->plane_reserved = false;
+				return;
+			}
+			rvgc_plane->plane_reserved = true;
+
+			ret = rvgc_taurus_layer_set_size(rcrvgc,
+							 display_idx,
+							 hw_plane,
+							 size_w,
+							 size_h,
+							 &res_msg);
+			if (ret) {
+				dev_err(rcrvgc->dev, "%s(): rvgc_taurus_layer_set_size(display=%d, id=%d, layer=%d) failed\n",
+					__FUNCTION__, display_idx, plane->base.id, hw_plane);
+			}
+			ret = rvgc_taurus_layer_set_pos(rcrvgc,
+							display_idx,
+							hw_plane,
+							pos_x,
+							pos_y,
+							&res_msg);
+			if (ret) {
+				dev_err(rcrvgc->dev, "%s(): rvgc_taurus_layer_set_position(display=%d, id=%d, layer=%d) failed\n",
+					__FUNCTION__, display_idx, plane->base.id, hw_plane);
+			}
+			return;
+		}
+
+		/* don't proceed from here if we don't actually have plane */
+		if (!rvgc_plane->plane_reserved) {
+			return;
+		}
+
+		if (old_state->fb && !plane->state->fb) {
+			/* disabling */
+			dev_info(rcrvgc->dev, "Release id=%d, layer=%d\n", plane->base.id, hw_plane);
+			ret = rvgc_taurus_layer_release(rcrvgc, display_idx, hw_plane, &res_msg);
+			rvgc_plane->plane_reserved = false;
+			if (ret) {
+				dev_err(rcrvgc->dev, "%s(): rvgc_taurus_layer_release(display=%d, id=%d, layer=%d) failed\n",
+					__FUNCTION__, display_idx, plane->base.id, hw_plane);
+			}
+			return;
+		}
 
-		drm_crtc_vblank_put(crtc);
+		if (plane->state->fb) {
+			/* updating fb */
+			gem_obj = drm_fb_cma_get_gem_obj(fb, 0); //we support only single planar formats
+			ret = rvgc_taurus_layer_set_addr(rcrvgc, display_idx, hw_plane, gem_obj->paddr, &res_msg);
+			if (ret) {
+				dev_err(rcrvgc->dev, "%s(): rvgc_taurus_layer_set_addr(display=%d, id=%d, layer=%d) failed\n",
+					__FUNCTION__, display_idx, plane->base.id, hw_plane);
+			}
+			return;
+		}
+
+		WARN_ON(!plane->state->fb);
 	}
 }
 
-static int rvgc_display_pipe_prepare_fb(struct drm_simple_display_pipe *pipe,
-					struct drm_plane_state *plane_state)
-{
-	return drm_gem_fb_prepare_fb(&pipe->plane, plane_state);
+static int rvgc_plane_prepare_fb(struct drm_plane* plane,
+				 struct drm_plane_state* state) {
+	return drm_gem_fb_prepare_fb(plane, state);
 }
 
-static const struct drm_simple_display_pipe_funcs rvgc_pipe_funcs = {
-	.enable = rvgc_pipe_enable,
-	.disable = rvgc_pipe_disable,
-	.update = rvgc_display_pipe_update,
-	.prepare_fb = rvgc_display_pipe_prepare_fb,
+static void rvgc_plane_cleanup_fb(struct drm_plane* plane,
+				  struct drm_plane_state* state) {
+
+}
+
+static const struct drm_plane_helper_funcs rvgc_plane_helper_funcs = {
+	.prepare_fb = rvgc_plane_prepare_fb,
+	.cleanup_fb = rvgc_plane_cleanup_fb,
+	.atomic_check = rvgc_plane_atomic_check,
+	.atomic_update = rvgc_plane_atomic_update,
 };
 
-static const u32 rvgc_formats[] = {
-        DRM_FORMAT_XRGB8888,
-        DRM_FORMAT_ARGB8888,
+static const struct drm_plane_funcs rvgc_plane_funcs = {
+	.update_plane		= drm_atomic_helper_update_plane,
+	.disable_plane		= drm_atomic_helper_disable_plane,
+	.destroy		= drm_plane_cleanup,
+	.reset			= drm_atomic_helper_plane_reset,
+	.atomic_duplicate_state	= drm_atomic_helper_plane_duplicate_state,
+	.atomic_destroy_state	= drm_atomic_helper_plane_destroy_state,
 };
 
-int rcar_rvgc_pipe_init(struct rcar_rvgc_device *rvgc_dev,
-			struct rcar_rvgc_pipe *rvgc_pipe)
-{
-	int ret = 0;
-	struct drm_device *drm = rvgc_dev->ddev;
-	struct drm_connector *connector;
-	struct taurus_rvgc_res_msg res_msg;
-	int rvgc_layer_width;
-	int rvgc_layer_height;
+static int overlay_pipe_init(struct rcar_rvgc_device* rvgc_dev,
+			     struct rcar_rvgc_pipe* rvgc_pipe) {
+
+	int ret = 0, i;
+	struct drm_device* ddev = rvgc_dev->ddev;
+	struct drm_crtc* crtc = &rvgc_pipe->crtc;
+	struct drm_encoder* encoder = &rvgc_pipe->encoder;
+	struct drm_connector* connector;
 
 	rvgc_pipe->rcar_rvgc_dev = rvgc_dev;
+	rvgc_pipe->event = NULL;
+	for (i = 0; i < rvgc_pipe->plane_nr; i++) {
+		enum drm_plane_type type = i == 0
+			? DRM_PLANE_TYPE_PRIMARY
+			: DRM_PLANE_TYPE_OVERLAY;
+
+		struct rcar_rvgc_plane* plane = &rvgc_pipe->planes[i];
+		plane->pipe = rvgc_pipe;
+
+		drm_plane_helper_add(&plane->plane, &rvgc_plane_helper_funcs);
+		ret = drm_universal_plane_init(ddev, &plane->plane,
+					       (1 << rvgc_pipe->idx),
+					       &rvgc_plane_funcs,
+					       rvgc_formats, ARRAY_SIZE(rvgc_formats), NULL,
+					       type, NULL);
+		if (ret)
+			return ret;
 
-	connector = rvgc_connector_create(rvgc_pipe);
+	}
 
-	ret = drm_simple_display_pipe_init(drm,
-					&rvgc_pipe->drm_simple_pipe,
-					&rvgc_pipe_funcs,
-					rvgc_formats, ARRAY_SIZE(rvgc_formats),
-					NULL,
-					connector);
-	if (ret) {
-		dev_err(rvgc_dev->dev,
-			"%s() drm_simple_display_pipe_init(pipe=%d) returned an error (%d)\n",
-			__FUNCTION__,
-			rvgc_pipe->idx,
-			ret);
+	drm_crtc_helper_add(crtc, &rvgc_crtc_helper_funcs);
+	ret = drm_crtc_init_with_planes(ddev, crtc, &rvgc_pipe->planes[0].plane, NULL,
+					&rvgc_crtc_funcs, NULL);
+	if (ret)
 		return ret;
-	}
+
+	encoder->possible_crtcs = 1 << drm_crtc_index(crtc);
+	ret = drm_encoder_init(ddev, encoder, &drm_simple_kms_encoder_funcs,
+			       DRM_MODE_ENCODER_NONE, NULL);
+	if (ret)
+		return ret;
+	connector = rvgc_connector_create(rvgc_pipe);
+
+	return drm_connector_attach_encoder(connector, encoder);
+
+}
+
+static int taurus_init(struct rcar_rvgc_device* rvgc_dev,
+		       struct rcar_rvgc_pipe* rvgc_pipe) {
+#if 0
+	struct rcar_rvgc_device* rcrvgc = rvgc_pipe->rcar_rvgc_dev;
+#endif
+	int ret = 0;
+	struct taurus_rvgc_res_msg res_msg;
 
 	ret = rvgc_taurus_display_init(rvgc_dev,
-				rvgc_pipe->display_mapping,
-				rvgc_pipe->display_layer,
-				&res_msg);
+				       rvgc_pipe->display_mapping,
+				       &res_msg);
 	if (ret) {
 		dev_err(rvgc_dev->dev, "%s(): rvgc_taurus_display_init(%d) failed\n",
 			__FUNCTION__,
@@ -313,8 +508,8 @@ int rcar_rvgc_pipe_init(struct rcar_rvgc_device *rvgc_dev,
 	}
 
 	ret = rvgc_taurus_display_get_info(rvgc_dev,
-					rvgc_pipe->display_mapping,
-					&res_msg);
+					   rvgc_pipe->display_mapping,
+					   &res_msg);
 	if (ret) {
 		dev_err(rvgc_dev->dev, "%s(): rvgc_taurus_display_get_info(%d) failed\n",
 			__FUNCTION__,
@@ -322,31 +517,27 @@ int rcar_rvgc_pipe_init(struct rcar_rvgc_device *rvgc_dev,
 		return ret;
 	}
 
-	rvgc_layer_width = res_msg.params.ioc_display_get_info.width;
-	rvgc_layer_height = res_msg.params.ioc_display_get_info.height;
+	/* not sure we'll use this, but keep the data */
+	rvgc_pipe->display_width = res_msg.params.ioc_display_get_info.width;
+	rvgc_pipe->display_height = res_msg.params.ioc_display_get_info.height;
 
-	ret = rvgc_taurus_layer_set_size(rvgc_dev,
-					rvgc_pipe->display_mapping,
-					rvgc_pipe->display_layer,
-					rvgc_layer_width,
-					rvgc_layer_height,
-					&res_msg);
-	if (ret) {
-		dev_err(rvgc_dev->dev, "%s(): rvgc_taurus_layer_set_size(display=%d, layer=%d) failed\n",
-			__FUNCTION__,
-			rvgc_pipe->display_mapping,
-			0);
-	}
+	return ret;
+}
 
+int rcar_rvgc_pipe_init(struct rcar_rvgc_device* rvgc_dev,
+			struct rcar_rvgc_pipe* rvgc_pipe) {
+	int ret = 0;
+	ret = overlay_pipe_init(rvgc_dev, rvgc_pipe);
+	if (ret) return ret;
+	ret = taurus_init(rvgc_dev, rvgc_pipe);
 	return ret;
 }
 
-struct rcar_rvgc_pipe* rvgc_pipe_find(struct rcar_rvgc_device *rcrvgc, unsigned int pipe_idx)
-{
-	struct rcar_rvgc_pipe *rvgc_pipe = NULL;
+struct rcar_rvgc_pipe* rvgc_pipe_find(struct rcar_rvgc_device* rcrvgc, unsigned int pipe_idx) {
+	struct rcar_rvgc_pipe* rvgc_pipe = NULL;
 	unsigned int nr_rvgc_pipes = rcrvgc->nr_rvgc_pipes;
 	int i;
-	for (i=0; i<nr_rvgc_pipes; i++) {
+	for (i = 0; i < nr_rvgc_pipes; i++) {
 		if (rcrvgc->rvgc_pipes[i].idx == pipe_idx) {
 			rvgc_pipe = &rcrvgc->rvgc_pipes[i];
 			break;
@@ -354,17 +545,3 @@ struct rcar_rvgc_pipe* rvgc_pipe_find(struct rcar_rvgc_device *rcrvgc, unsigned
 	}
 	return rvgc_pipe;
 }
-
-struct rcar_rvgc_pipe* rvgc_pipe_find_by_display(struct rcar_rvgc_device *rcrvgc, unsigned int display_mapping)
-{
-	struct rcar_rvgc_pipe *rvgc_pipe = NULL;
-	unsigned int nr_rvgc_pipes = rcrvgc->nr_rvgc_pipes;
-	int i;
-	for (i=0; i < nr_rvgc_pipes; i++) {
-		if (rcrvgc->rvgc_pipes[i].display_mapping == display_mapping) {
-			rvgc_pipe = &rcrvgc->rvgc_pipes[i];
-			break;
-		}
-	}
-	return rvgc_pipe;
-}
\ No newline at end of file
diff --git a/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_pipe.h b/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_pipe.h
index 42fed506bfdb..e3fcbe985da7 100644
--- a/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_pipe.h
+++ b/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_pipe.h
@@ -20,22 +20,38 @@
 struct rcar_rvgc_device;
 struct drm_crtc;
 
+struct rcar_rvgc_plane {
+	unsigned int hw_plane;
+	unsigned int size_w;
+	unsigned int size_h;
+	unsigned int pos_x;
+	unsigned int pos_y;
+	bool pos_override;	/* always use rcar_rvgc_plane position (read from FDT) */
+	bool size_override;	/* always use rcar_rvgc_plane size (read from FDT) */
+	bool no_scan;		/* don't output this plane to vspd */
+	bool plane_reserved;	/* we've actually managed to allocate a hardware plane */
+	struct drm_plane plane;
+	struct rcar_rvgc_pipe* pipe;
+};
+
 struct rcar_rvgc_pipe {
-	struct rcar_rvgc_device *rcar_rvgc_dev;
+	struct rcar_rvgc_device* rcar_rvgc_dev;
 	unsigned int idx;
 	unsigned int display_mapping;
-	unsigned int display_layer;
 	unsigned int vblank_enabled;
-	struct drm_simple_display_pipe drm_simple_pipe;
-	struct drm_pending_vblank_event *event;
+	unsigned int plane_nr;
+	unsigned int display_height;
+	unsigned int display_width;
+
+	struct drm_crtc crtc;
+	struct rcar_rvgc_plane* planes;
+	struct drm_encoder encoder;
+	struct drm_connector* connector;
 
-	struct task_struct *vsync_thread;
-	atomic_t global_vblank_enable;
-	uint8_t vblank_pending;
+	struct drm_pending_vblank_event* event;
 };
 
-int rcar_rvgc_pipe_init(struct rcar_rvgc_device *rvgc_dev, struct rcar_rvgc_pipe *rvgc_pipe);
-struct rcar_rvgc_pipe* rvgc_pipe_find(struct rcar_rvgc_device *rcrvgc, unsigned int pipe_idx);
-struct rcar_rvgc_pipe* rvgc_pipe_find_by_display(struct rcar_rvgc_device *rcrvgc, unsigned int display_mapping);
+int rcar_rvgc_pipe_init(struct rcar_rvgc_device* rvgc_dev, struct rcar_rvgc_pipe* rvgc_pipe);
+struct rcar_rvgc_pipe* rvgc_pipe_find(struct rcar_rvgc_device* rcrvgc, unsigned int pipe_idx);
 
 #endif /* __RCAR_RVGC_PIPE_H__ */
diff --git a/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_taurus.c b/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_taurus.c
index 480fdc5ec139..a5155818e393 100644
--- a/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_taurus.c
+++ b/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_taurus.c
@@ -10,18 +10,16 @@
 
 static atomic_t rpmsg_id_counter = ATOMIC_INIT(0);
 
-static int rvgc_taurus_get_uniq_id(void)
-{
+static int rvgc_taurus_get_uniq_id(void) {
 	return atomic_inc_return(&rpmsg_id_counter);
 }
 
-static int rvgc_taurus_send_command(struct rcar_rvgc_device *rcrvgc,
-				struct taurus_rvgc_cmd_msg *cmd_msg,
-				struct taurus_rvgc_res_msg *res_msg)
-{
-	struct taurus_event_list *event;
-	struct rpmsg_device *rpdev = rcrvgc->rpdev;
-	struct device *dev = rcrvgc->dev;
+static int rvgc_taurus_send_command(struct rcar_rvgc_device* rcrvgc,
+				    struct taurus_rvgc_cmd_msg* cmd_msg,
+				    struct taurus_rvgc_res_msg* res_msg) {
+	struct taurus_event_list* event;
+	struct rpmsg_device* rpdev = rcrvgc->rpdev;
+	struct device* dev = rcrvgc->dev;
 	int ret = 0;
 
 	event = devm_kzalloc(dev, sizeof(*event), GFP_KERNEL);
@@ -75,22 +73,21 @@ static int rvgc_taurus_send_command(struct rcar_rvgc_device *rcrvgc,
 
 	memcpy(res_msg, event->result, sizeof(struct taurus_rvgc_res_msg));
 
-cleanup_3:
+ cleanup_3:
 	write_lock(&rcrvgc->event_list_lock);
 	list_del(&event->list);
 	write_unlock(&rcrvgc->event_list_lock);
 	devm_kfree(&rpdev->dev, event->result);
-cleanup_2:
+ cleanup_2:
 	devm_kfree(&rpdev->dev, event);
-cleanup_1:
+ cleanup_1:
 	return ret;
 }
 
-int rvgc_taurus_display_init(struct rcar_rvgc_device *rcrvgc,
-			uint32_t display,
-			uint32_t layer,
-			struct taurus_rvgc_res_msg *res_msg)
-{
+int rvgc_taurus_plane_reserve(struct rcar_rvgc_device* rcrvgc,
+			      uint32_t display,
+			      uint32_t layer,
+			      struct taurus_rvgc_res_msg* res_msg) {
 	struct taurus_rvgc_cmd_msg cmd_msg;
 	int ret;
 
@@ -100,45 +97,56 @@ int rvgc_taurus_display_init(struct rcar_rvgc_device *rcrvgc,
 	cmd_msg.hdr.Id = rvgc_taurus_get_uniq_id();
 	cmd_msg.hdr.Channel = RVGC_TAURUS_CHANNEL;
 	cmd_msg.hdr.Cmd = R_TAURUS_CMD_IOCTL;
-	cmd_msg.hdr.Par1 = RVGC_PROTOCOL_IOC_DISPLAY_INIT;
-	cmd_msg.type = RVGC_PROTOCOL_IOC_DISPLAY_INIT;
-	cmd_msg.params.ioc_display_flush.cookie = cmd_msg.hdr.Id;
-	cmd_msg.params.ioc_display_flush.display = display;
+	cmd_msg.hdr.Par1 = RVGC_PROTOCOL_IOC_LAYER_RESERVE;
+	cmd_msg.type = RVGC_PROTOCOL_IOC_LAYER_RESERVE;
+	cmd_msg.params.ioc_layer_reserve.cookie = cmd_msg.hdr.Id;
+	cmd_msg.params.ioc_layer_reserve.display = display;
+	cmd_msg.params.ioc_layer_reserve.layer = layer;
 
 	ret = rvgc_taurus_send_command(rcrvgc, &cmd_msg, res_msg);
 	if (ret)
 		return -EPIPE;
 
 	if ((res_msg->hdr.Result != R_TAURUS_RES_COMPLETE) ||
-		(res_msg->params.ioc_display_init.res != 0)) {
+	    (res_msg->params.ioc_layer_reserve.res != 0)) {
 		return -EIO;
 	}
 
+	return 0;
+}
+
+
+int rvgc_taurus_display_init(struct rcar_rvgc_device* rcrvgc,
+			     uint32_t display,
+			     struct taurus_rvgc_res_msg* res_msg) {
+	struct taurus_rvgc_cmd_msg cmd_msg;
+	int ret = 0;
+
+	if (!res_msg)
+		return -EINVAL;
+
 	cmd_msg.hdr.Id = rvgc_taurus_get_uniq_id();
 	cmd_msg.hdr.Channel = RVGC_TAURUS_CHANNEL;
 	cmd_msg.hdr.Cmd = R_TAURUS_CMD_IOCTL;
-	cmd_msg.hdr.Par1 = RVGC_PROTOCOL_IOC_LAYER_RESERVE;
-	cmd_msg.type = RVGC_PROTOCOL_IOC_LAYER_RESERVE;
-	cmd_msg.params.ioc_layer_reserve.cookie = cmd_msg.hdr.Id;
-	cmd_msg.params.ioc_layer_reserve.display = display;
-	cmd_msg.params.ioc_layer_reserve.layer = layer;
+	cmd_msg.hdr.Par1 = RVGC_PROTOCOL_IOC_DISPLAY_INIT;
+	cmd_msg.type = RVGC_PROTOCOL_IOC_DISPLAY_INIT;
+	cmd_msg.params.ioc_display_flush.cookie = cmd_msg.hdr.Id;
+	cmd_msg.params.ioc_display_flush.display = display;
 
 	ret = rvgc_taurus_send_command(rcrvgc, &cmd_msg, res_msg);
 	if (ret)
 		return -EPIPE;
 
 	if ((res_msg->hdr.Result != R_TAURUS_RES_COMPLETE) ||
-		(res_msg->params.ioc_layer_reserve.res != 0)) {
+	    (res_msg->params.ioc_display_init.res != 0)) {
 		return -EIO;
 	}
-
-	return 0;
+	return ret;
 }
 
-int rvgc_taurus_display_get_info(struct rcar_rvgc_device *rcrvgc,
-				uint32_t display,
-				struct taurus_rvgc_res_msg *res_msg)
-{
+int rvgc_taurus_display_get_info(struct rcar_rvgc_device* rcrvgc,
+				 uint32_t display,
+				 struct taurus_rvgc_res_msg* res_msg) {
 	struct taurus_rvgc_cmd_msg cmd_msg;
 	int ret;
 
@@ -158,18 +166,17 @@ int rvgc_taurus_display_get_info(struct rcar_rvgc_device *rcrvgc,
 		return -EPIPE;
 
 	if ((res_msg->hdr.Result != R_TAURUS_RES_COMPLETE) ||
-		(res_msg->params.ioc_display_get_info.res != 0)) {
+	    (res_msg->params.ioc_display_get_info.res != 0)) {
 		return -EIO;
 	}
 
 	return 0;
 }
 
-int rvgc_taurus_display_flush(struct rcar_rvgc_device *rcrvgc,
-			uint32_t display,
-			uint32_t blocking,
-			struct taurus_rvgc_res_msg *res_msg)
-{
+int rvgc_taurus_display_flush(struct rcar_rvgc_device* rcrvgc,
+			      uint32_t display,
+			      uint32_t blocking,
+			      struct taurus_rvgc_res_msg* res_msg) {
 	struct taurus_rvgc_cmd_msg cmd_msg;
 	int ret;
 
@@ -190,20 +197,19 @@ int rvgc_taurus_display_flush(struct rcar_rvgc_device *rcrvgc,
 		return -EPIPE;
 
 	if ((res_msg->hdr.Result != R_TAURUS_RES_COMPLETE) ||
-		(res_msg->params.ioc_display_flush.res != 0)) {
+	    (res_msg->params.ioc_display_flush.res != 0)) {
 		return -EIO;
 	}
 
 	return 0;
 }
 
-int rvgc_taurus_layer_set_size(struct rcar_rvgc_device *rcrvgc,
-			uint32_t display,
-			uint32_t layer,
-			uint32_t width,
-			uint32_t height,
-			struct taurus_rvgc_res_msg *res_msg)
-{
+int rvgc_taurus_layer_set_size(struct rcar_rvgc_device* rcrvgc,
+			       uint32_t display,
+			       uint32_t layer,
+			       uint32_t width,
+			       uint32_t height,
+			       struct taurus_rvgc_res_msg* res_msg) {
 	struct taurus_rvgc_cmd_msg cmd_msg;
 	int ret;
 
@@ -226,19 +232,53 @@ int rvgc_taurus_layer_set_size(struct rcar_rvgc_device *rcrvgc,
 		return -EPIPE;
 
 	if ((res_msg->hdr.Result != R_TAURUS_RES_COMPLETE) ||
-		(res_msg->params.ioc_layer_set_size.res != 0)) {
+	    (res_msg->params.ioc_layer_set_size.res != 0)) {
 		return -EIO;
 	}
 
 	return 0;
 }
 
-int rvgc_taurus_layer_set_addr(struct rcar_rvgc_device *rcrvgc,
-			uint32_t display,
-			uint32_t layer,
-			uint32_t paddr,
-			struct taurus_rvgc_res_msg *res_msg)
-{
+int rvgc_taurus_layer_set_pos(struct rcar_rvgc_device* rcrvgc,
+			      uint32_t display,
+			      uint32_t layer,
+			      uint32_t pos_x,
+			      uint32_t pos_y,
+			      struct taurus_rvgc_res_msg* res_msg) {
+	struct taurus_rvgc_cmd_msg cmd_msg;
+	int ret;
+
+	if (!res_msg)
+		return -EINVAL;
+
+	cmd_msg.hdr.Id = rvgc_taurus_get_uniq_id();
+	cmd_msg.hdr.Channel = RVGC_TAURUS_CHANNEL;
+	cmd_msg.hdr.Cmd = R_TAURUS_CMD_IOCTL;
+	cmd_msg.hdr.Par1 = RVGC_PROTOCOL_IOC_LAYER_SET_POS;
+	cmd_msg.type = RVGC_PROTOCOL_IOC_LAYER_SET_POS;
+	cmd_msg.params.ioc_layer_set_pos.cookie =  cmd_msg.hdr.Id;
+	cmd_msg.params.ioc_layer_set_pos.display = display;
+	cmd_msg.params.ioc_layer_set_pos.layer = layer;
+	cmd_msg.params.ioc_layer_set_pos.pos_x = pos_x;
+	cmd_msg.params.ioc_layer_set_pos.pos_y = pos_y;
+
+	ret = rvgc_taurus_send_command(rcrvgc, &cmd_msg, res_msg);
+	if (ret)
+		return -EPIPE;
+
+	if ((res_msg->hdr.Result != R_TAURUS_RES_COMPLETE) ||
+	    (res_msg->params.ioc_layer_set_pos.res != 0)) {
+		return -EIO;
+	}
+
+	return 0;
+}
+
+int rvgc_taurus_layer_set_addr(struct rcar_rvgc_device* rcrvgc,
+			       uint32_t display,
+			       uint32_t layer,
+			       uint32_t paddr,
+			       struct taurus_rvgc_res_msg* res_msg) {
 	struct taurus_rvgc_cmd_msg cmd_msg;
 	int ret;
 
@@ -260,7 +300,38 @@ int rvgc_taurus_layer_set_addr(struct rcar_rvgc_device *rcrvgc,
 		return -EPIPE;
 
 	if ((res_msg->hdr.Result != R_TAURUS_RES_COMPLETE) ||
-		(res_msg->params.ioc_layer_set_addr.res != 0)) {
+	    (res_msg->params.ioc_layer_set_addr.res != 0)) {
+		return -EIO;
+	}
+
+	return 0;
+}
+
+int rvgc_taurus_layer_release(struct rcar_rvgc_device* rcrvgc,
+			      uint32_t display,
+			      uint32_t layer,
+			      struct taurus_rvgc_res_msg* res_msg) {
+	struct taurus_rvgc_cmd_msg cmd_msg;
+	int ret;
+
+	if (!res_msg)
+		return -EINVAL;
+
+	cmd_msg.hdr.Id = rvgc_taurus_get_uniq_id();
+	cmd_msg.hdr.Channel = RVGC_TAURUS_CHANNEL;
+	cmd_msg.hdr.Cmd = R_TAURUS_CMD_IOCTL;
+	cmd_msg.hdr.Par1 = RVGC_PROTOCOL_IOC_LAYER_RELEASE;
+	cmd_msg.type = RVGC_PROTOCOL_IOC_LAYER_RELEASE;
+	cmd_msg.params.ioc_layer_release.cookie =  cmd_msg.hdr.Id;
+	cmd_msg.params.ioc_layer_release.display = display;
+	cmd_msg.params.ioc_layer_release.layer = layer;
+
+	ret = rvgc_taurus_send_command(rcrvgc, &cmd_msg, res_msg);
+	if (ret)
+		return -EPIPE;
+
+	if ((res_msg->hdr.Result != R_TAURUS_RES_COMPLETE) ||
+	    (res_msg->params.ioc_layer_release.res != 0)) {
 		return -EIO;
 	}
 
diff --git a/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_taurus.h b/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_taurus.h
index 19d3b6ba840b..c8ccf1ff1fd1 100644
--- a/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_taurus.h
+++ b/drivers/gpu/drm/rcar-rvgc/rcar_rvgc_taurus.h
@@ -6,31 +6,47 @@
 struct rcar_rvgc_device;
 struct taurus_rvgc_res_msg;
 
-int rvgc_taurus_display_init(struct rcar_rvgc_device *rcrvgc,
-			uint32_t display,
-			uint32_t layer,
-			struct taurus_rvgc_res_msg *res_msg);
-
-int rvgc_taurus_display_get_info(struct rcar_rvgc_device *rcrvgc,
-				uint32_t display,
-				struct taurus_rvgc_res_msg *res_msg);
-
-int rvgc_taurus_display_flush(struct rcar_rvgc_device *rcrvgc,
-			uint32_t display,
-			uint32_t blocking,
-			struct taurus_rvgc_res_msg *res_msg);
-
-int rvgc_taurus_layer_set_addr(struct rcar_rvgc_device *rcrvgc,
-			uint32_t display,
-			uint32_t layer,
-			uint32_t paddr,
-			struct taurus_rvgc_res_msg *res_msg);
-
-int rvgc_taurus_layer_set_size(struct rcar_rvgc_device *rcrvgc,
-			uint32_t display,
-			uint32_t layer,
-			uint32_t width,
-			uint32_t height,
-			struct taurus_rvgc_res_msg *res_msg);
+int rvgc_taurus_display_init(struct rcar_rvgc_device* rcrvgc,
+			     uint32_t display,
+			     struct taurus_rvgc_res_msg* res_msg);
+
+int rvgc_taurus_plane_reserve(struct rcar_rvgc_device* rcrvgc,
+			      uint32_t display,
+			      uint32_t layer,
+			      struct taurus_rvgc_res_msg* res_msg);
+
+int rvgc_taurus_display_get_info(struct rcar_rvgc_device* rcrvgc,
+				 uint32_t display,
+				 struct taurus_rvgc_res_msg* res_msg);
+
+int rvgc_taurus_display_flush(struct rcar_rvgc_device* rcrvgc,
+			      uint32_t display,
+			      uint32_t blocking,
+			      struct taurus_rvgc_res_msg* res_msg);
+
+int rvgc_taurus_layer_set_addr(struct rcar_rvgc_device* rcrvgc,
+			       uint32_t display,
+			       uint32_t layer,
+			       uint32_t paddr,
+			       struct taurus_rvgc_res_msg* res_msg);
+
+int rvgc_taurus_layer_release(struct rcar_rvgc_device* rcrvgc,
+			      uint32_t display,
+			      uint32_t layer,
+			      struct taurus_rvgc_res_msg* res_msg);
+
+int rvgc_taurus_layer_set_size(struct rcar_rvgc_device* rcrvgc,
+			       uint32_t display,
+			       uint32_t layer,
+			       uint32_t width,
+			       uint32_t height,
+			       struct taurus_rvgc_res_msg* res_msg);
+
+int rvgc_taurus_layer_set_pos(struct rcar_rvgc_device* rcrvgc,
+			      uint32_t display,
+			      uint32_t layer,
+			      uint32_t pos_x,
+			      uint32_t pos_y,
+			      struct taurus_rvgc_res_msg* res_msg);
 
 #endif /* __RCAR_RVGC_TAURUS_H__ */
-- 
2.25.1

